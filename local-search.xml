<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>回合式類寶可夢精靈對戰系統</title>
    <link href="/webHome/%5Bobject%20Object%5D/2023/08/16/game-develope/%E5%9B%9E%E5%90%88%E5%BC%8F%E9%A1%9E%E5%AF%B6%E5%8F%AF%E5%A4%A2%E7%B2%BE%E9%9D%88%E5%B0%8D%E6%88%B0%E7%B3%BB%E7%B5%B1/"/>
    <url>/webHome/%5Bobject%20Object%5D/2023/08/16/game-develope/%E5%9B%9E%E5%90%88%E5%BC%8F%E9%A1%9E%E5%AF%B6%E5%8F%AF%E5%A4%A2%E7%B2%BE%E9%9D%88%E5%B0%8D%E6%88%B0%E7%B3%BB%E7%B5%B1/</url>
    
    <content type="html"><![CDATA[<h1 id="回合式類寶可夢精靈對戰系統"><a href="#回合式類寶可夢精靈對戰系統" class="headerlink" title="回合式類寶可夢精靈對戰系統"></a>回合式類寶可夢精靈對戰系統</h1><p>github連結(<a href="https://github.com/z-hwa/SummonersGame">https://github.com/z-hwa/SummonersGame</a>)</p><img src="https://cdn.jsdelivr.net/gh/z-hwa/webHomeImage/image/turns%20game%20cover.PNG" width=50%/><h2 id="系統概述"><a href="#系統概述" class="headerlink" title="系統概述"></a>系統概述</h2><p>主要是完成回合式對戰遊戲中的戰鬥場景，並實現精靈、技能、屬性、個性等等系統</p><p>當遊戲啟動以後，將會自動載入預先創建好的精靈<strong>雪莉</strong>，接著載入敵人，同樣也是<strong>雪莉</strong>。</p><p>整個遊戲的狀態，由Unity內建的Debug.log函數做輸出，並沒有實現在遊戲窗口的狀態廣播。</p><p>首先會進行雙方單位的速度能力值比較(相同的情況下，預設為玩家方優先)，並進入對應單位的回合。</p><p>進入整個以IEnumerator為主的循環中，並在回合操作後，檢測雙方的背包中，是否仍有可行動的單位。</p><p>判斷是否進入勝敗的狀況，或是進到對方的IEnumerator函數中，等待下一步操作。</p><h2 id="主邏輯"><a href="#主邏輯" class="headerlink" title="主邏輯"></a>主邏輯</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>以BattleSystem為戰鬥中的主流程操控。</p><p>並透過Enum來紀錄當前的場景狀況。</p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-comment">//系統可能的狀態</span><span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> BattleState &#123;    START = <span class="hljs-number">0</span>,    PLAYERTURN,    ENEMYTURN,    WON,    LOSE&#125;</code></pre></div><p>BattleSystem預設以UnitBattleData創建兩個實體，並在開始時，載入雙方的單位資料，分別代表玩家以及敵人，在戰鬥中的所有數據紀錄</p><p>接著BattleSystem呼叫UISystem的LoadUIData()，載入所有的UI資訊</p><p>下一步，透過BattleSystem內的PreemtiveTest()函數，進行速度比較。</p><p>接著，進入IEnumerator中(雙方回合)。</p><h3 id="玩家回合"><a href="#玩家回合" class="headerlink" title="玩家回合"></a>玩家回合</h3><p><em>利用Unity的Button等待玩家進行動作</em></p><ul><li>施放技能<ul><li>透過BattleSystem呼喚SkillSystem的UsingSkll()函數，施放技能</li></ul></li><li>更換精靈<ul><li>透過BattleSystem下的ChooseUnit()來更換精靈</li><li>並透過BattleSystem下的UISystem來更新UI</li></ul></li></ul><p><em>透過UISystem更新UI</em></p><p><em>檢測敵人是否輸了</em></p><ul><li>是:進入勝利狀態，結束遊戲</li><li>否:進入敵人回合，繼續遊戲</li></ul><h3 id="敵人回合"><a href="#敵人回合" class="headerlink" title="敵人回合"></a>敵人回合</h3><p><em>BattleSystem呼叫EnemyAISystem中的AIModeUsing，switch進該名敵方單位設定的AI模式呼叫</em></p><p><em>根據AI模式，傳回該使用的技能ID</em></p><ul><li>透過BattleSystem呼喚SkillSystem的UsingSkll()函數，施放技能</li></ul><p><em>檢測玩家是否輸了</em></p><ul><li>是:進入勝利狀態，結束遊戲</li><li>否:進入玩家回合，繼續遊戲</li></ul><h2 id="BattleSystem"><a href="#BattleSystem" class="headerlink" title="BattleSystem"></a>BattleSystem</h2><h3 id="玩家IEnumerator"><a href="#玩家IEnumerator" class="headerlink" title="玩家IEnumerator"></a>玩家IEnumerator</h3><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-comment">//玩家回合</span><span class="hljs-function">IEnumerator <span class="hljs-title">PlayerTurn</span>()</span>&#123;        <span class="hljs-built_in">bool</span> isEnemyLose = <span class="hljs-literal">false</span>;   <span class="hljs-comment">//標示敵人是否戰敗</span>    isUsingSkill = <span class="hljs-literal">false</span>;  <span class="hljs-comment">//檢測是否施放技能</span>    OnInteractable_SkillButton();   <span class="hljs-comment">//激活技能按鍵</span>    Debug.Log(<span class="hljs-string">&quot;你的回合 請選擇......&quot;</span>);    <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">WaitUntil</span>(<span class="hljs-params">(</span>)</span> =&gt; isUsingSkill); <span class="hljs-comment">//等待直到施放技能</span>    <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">WaitForSeconds</span>(<span class="hljs-params"><span class="hljs-number">2f</span></span>)</span>;    <span class="hljs-comment">//等待技能動畫或技能效果實現</span>    <span class="hljs-comment">/*</span><span class="hljs-comment">    RenewUIData();    //更新UI</span><span class="hljs-comment"></span><span class="hljs-comment">    isEnemyLose = CheckEnemyIsLose();   //檢測敵人是否輸了</span><span class="hljs-comment"></span><span class="hljs-comment">    /* 兩種情況的檢測</span><span class="hljs-comment">     *      進入敵方回合</span><span class="hljs-comment">     *      勝利</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">if</span>(isEnemyLose == <span class="hljs-literal">true</span>)    &#123;        Debug.Log(<span class="hljs-string">&quot;你勝利了&quot;</span>);        battleState = BattleState.WON;        <span class="hljs-comment">//BattleWon();</span>    &#125;<span class="hljs-keyword">else</span>    &#123;        battleState = BattleState.ENEMYTURN;        StartCoroutine(EnemyTurn());  <span class="hljs-comment">//敵人回合</span>    &#125;&#125;</code></pre></div><h3 id="敵人IEnumerator"><a href="#敵人IEnumerator" class="headerlink" title="敵人IEnumerator"></a>敵人IEnumerator</h3><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-comment">//敵方回合</span><span class="hljs-function">IEnumerator <span class="hljs-title">EnemyTurn</span>()</span>&#123;    <span class="hljs-built_in">int</span> playerStatus = <span class="hljs-number">0</span>;   <span class="hljs-comment">/* 標示玩家是否戰敗</span><span class="hljs-comment">                             * 0 未戰敗 可繼續戰鬥</span><span class="hljs-comment">                             * 1 戰敗</span><span class="hljs-comment">                             * 2 當前單位戰敗 但可以更換單位繼續戰鬥</span><span class="hljs-comment">                             */</span>    <span class="hljs-built_in">int</span> skillID = <span class="hljs-number">-1</span>;   <span class="hljs-comment">//將要進行的技能ID</span>    Debug.Log(<span class="hljs-string">&quot;敵方回合......&quot;</span>);    Debug.Log(<span class="hljs-string">&quot;敵方發起攻擊&quot;</span>);            skillID = enemyAISystem.AIModeUsing(enemyBattleData.enemyAIID);     <span class="hljs-comment">//從AI系統 獲得敵人行為模式</span>    skillSystem.UsingSkill(skillID, enemyBattleData, playerBattleData);     <span class="hljs-comment">//發動技能</span>    <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">WaitForSeconds</span>(<span class="hljs-params"><span class="hljs-number">2f</span></span>)</span>;    <span class="hljs-comment">//等待技能動畫或技能效果實現</span>    RenewUIData(); <span class="hljs-comment">//更新UI</span>    playerStatus = CheckPlayerIsLose();   <span class="hljs-comment">//檢測玩家是否輸了</span>    <span class="hljs-comment">/* 兩種情況的檢測</span><span class="hljs-comment">     *      進入敵方回合</span><span class="hljs-comment">     *      勝利</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">if</span> (playerStatus == <span class="hljs-number">1</span>)    &#123;        Debug.Log(<span class="hljs-string">&quot;你輸拉&quot;</span>);        battleState = BattleState.LOSE;        <span class="hljs-comment">//BattleLose();</span>    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(playerStatus == <span class="hljs-number">0</span>)    &#123;            battleState = BattleState.PLAYERTURN;        StartCoroutine(PlayerTurn());  <span class="hljs-comment">//玩家回合</span>    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(playerStatus == <span class="hljs-number">2</span>)    &#123;        Debug.Log(<span class="hljs-string">&quot;當前單位戰敗 請更換單位!&quot;</span>);        battleState = BattleState.PLAYERTURN;        StartCoroutine(PlayerTurn());  <span class="hljs-comment">//玩家回合</span>    &#125;&#125;</code></pre></div><p>戰鬥系統的核心邏輯腳本<br>基本上就是讓流程在兩個IEnumerator中，去進行<br>並在發生終止條件(比出勝負)後，跳出這個IEnumerator中</p><h2 id="單位系統"><a href="#單位系統" class="headerlink" title="單位系統"></a>單位系統</h2><p>單位系統是多個子系統的概念複合體，包含了以下數個腳本、實體系統</p><ul><li>UnitObject(Scriptal Object):<ul><li>腳本資料</li><li>包含一個腳色的所有資訊</li><li>紀錄一種精靈的設定(不變動)</li></ul></li><li>UnitBattleData:<ul><li>作為精靈背包資料的實體(6格)</li><li>作為玩家、敵人資料的變數(2格)</li><li>會從UnitObject中載入精靈資料</li><li>更換精靈時，即是直接將背包資料的實體ref，賦給玩家資料的變數</li></ul></li><li>CharacterSystem:<ul><li>記錄所有精靈的個性(影響升級時的能力值分配)</li><li>記錄所有個性的能力值分配方式</li></ul></li><li>AttributeSystem:<ul><li>記錄所有精靈的屬性</li><li>記錄所有屬性的克制關係</li></ul></li><li>EnemyAISystem:<ul><li>統整併處理敵人AI的使用</li><li>在Scripts&#x2F;Enemy&#x2F;AI下，放置各種AI模式的腳本</li><li>需要手動添加新的AI模式到代碼裡</li></ul></li><li>PackageSystem:<ul><li>保存6個UnitBattleData的實體</li><li>用於野外場景到戰鬥場景的資料傳輸by SO</li><li>用於戰鬥場景的初始化</li></ul></li></ul><h2 id="SkillSystem"><a href="#SkillSystem" class="headerlink" title="SkillSystem"></a>SkillSystem</h2><p>用於處理所有的技能施放，並根據使用的技能ID，找到對應的技能代碼，產生效果</p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-comment">//根據ID施放技能</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">UsingSkill</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> skillID, UnitBattleData attaker, UnitBattleData defensor</span>)</span>    &#123;        <span class="hljs-keyword">switch</span> (skillID)        &#123;            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:                UseSkill_0(attaker, defensor);                <span class="hljs-keyword">break</span>;            <span class="hljs-literal">default</span>:                Debug.Log(<span class="hljs-string">&quot;查無檢索&quot;</span>);                <span class="hljs-keyword">break</span>;        &#125;    &#125;</code></pre></div><p>也包含透過技能ID，查找SkillData實體，保存的技能資料，以讓UISystem可以顯示技能資訊</p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-comment">//根據ID找到技能的名稱</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> <span class="hljs-title">CheckSkillName</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> skillID</span>)</span>   &#123;       <span class="hljs-comment">//確認當前資料庫長度</span>       <span class="hljs-comment">//預設目標技能index為0</span>       <span class="hljs-built_in">int</span> dataSize = skillData.data.Length;       <span class="hljs-built_in">int</span> targetSkill_Index = <span class="hljs-number">0</span>;       <span class="hljs-comment">//遍歷資料庫查詢技能</span>       <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;dataSize;i++)       &#123;           <span class="hljs-keyword">if</span>(skillID == skillData.data[i].ID)           &#123;               <span class="hljs-comment">//找到 設定目標index</span>               targetSkill_Index = i;               <span class="hljs-keyword">break</span>;           &#125;<span class="hljs-keyword">else</span>           &#123;               <span class="hljs-comment">//沒有找到</span>               Debug.Log(<span class="hljs-string">&quot;do not find the &quot;</span> + skillID + <span class="hljs-string">&quot; ID skill in data&quot;</span>);           &#125;       &#125;       <span class="hljs-keyword">return</span> skillData.data[targetSkill_Index].skillName;   &#125;</code></pre></div><p>技能資料的儲存，同樣透過SO(Scriptal Object)的方式完成</p><div class="code-wrapper"><pre><code class="hljs csharp">[<span class="hljs-meta">CreateAssetMenu(fileName = <span class="hljs-string">&quot;skill&quot;</span>, menuName = <span class="hljs-string">&quot;Unit/New Skill&quot;</span>)</span>]<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SkillObject</span> : <span class="hljs-title">ScriptableObject</span>&#123;    [<span class="hljs-meta">Header(<span class="hljs-string">&quot;技能敘述&quot;</span>)</span>]    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> skillName;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> ID;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> learnLevel;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> power;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> pp;    [<span class="hljs-meta">TextArea</span>]  <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> skillEffect;  <span class="hljs-comment">//技能效果</span>    [<span class="hljs-meta">TextArea</span>]  <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> skillIntro;   <span class="hljs-comment">//技能敘述</span>&#125;</code></pre></div><h2 id="新資料創建"><a href="#新資料創建" class="headerlink" title="新資料創建"></a>新資料創建</h2><h4 id="單位"><a href="#單位" class="headerlink" title="單位"></a>單位</h4><p>透過UnitObject的SO，快速創建精靈的單位(根据設定集)</p><h4 id="技能"><a href="#技能" class="headerlink" title="技能"></a>技能</h4><p>透過SkillData的SO，創建精靈的技能描述、文本資料<br>並在SkillSystem中，完成相對ID的技能程式碼</p><h4 id="個性"><a href="#個性" class="headerlink" title="個性"></a>個性</h4><p>在CharacterSystem中，可以直接創建新的個性Enum<br>並設定相關的升級數值分配方式</p><h4 id="屬性"><a href="#屬性" class="headerlink" title="屬性"></a>屬性</h4><p>在AttributeSystem中，可以直接創建新的屬性Enum<br>並設定相關的屬性克制倍率</p><h4 id="AI"><a href="#AI" class="headerlink" title="AI"></a>AI</h4><p>在Scripts&#x2F;Enemy&#x2F;AI中，撰寫新的AI腳本<br>並在EnemyAISystem中，添加該腳本用於呼叫<br>(預設為單位的ID，直接使用該ID的AI腳本，如果沒有該ID的AI腳本，則使用Default)</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p>Turn-Based Combat in Unity, from <a href="https://www.youtube.com/watch?v=_1pz_ohupPs">https://www.youtube.com/watch?v=_1pz_ohupPs</a></p><p>[Unity3D]ScriptableObject解析，來自<br><a href="https://zhuanlan.zhihu.com/p/417241353">https://zhuanlan.zhihu.com/p/417241353</a></p><p>C# 拷贝数组的几种方法，來自 <a href="https://www.cnblogs.com/makesense/p/4461016.html">https://www.cnblogs.com/makesense/p/4461016.html</a></p><p>Unity Editor | 系列簡介與Inspector 小技巧 #1，來自 <a href="https://vocus.cc/article/63db8783fd89780001454ccf">https://vocus.cc/article/63db8783fd89780001454ccf</a></p><p>Unity 中 创建 TextMeshPro 中文字体（含常见汉字 TXT 文件），來自 <a href="https://blog.csdn.net/qq_37454669/article/details/121128100">https://blog.csdn.net/qq_37454669/article/details/121128100</a></p><p>Unity进阶：ScriptableObject使用指南，來自 <a href="https://blog.csdn.net/qq_46044366/article/details/124310241">https://blog.csdn.net/qq_46044366/article/details/124310241</a></p><p>赛尔号伤害计算公式，來自 <a href="https://news.4399.com/seer/jingyanxinde/201209-05-194310.html">https://news.4399.com/seer/jingyanxinde/201209-05-194310.html</a></p><p>C# 枚举（Enum），來自<a href="https://www.runoob.com/csharp/csharp-enum.html">https://www.runoob.com/csharp/csharp-enum.html</a></p><p>Unity不同脚本之间的执行顺序，來自<a href="https://gwb.tencent.com/community/detail/128278">https://gwb.tencent.com/community/detail/128278</a></p><p>Unity Coroutine 使用筆記，來自<a href="https://dev.twsiyuan.com/2017/05/unity-coroutine.html">https://dev.twsiyuan.com/2017/05/unity-coroutine.html</a></p><p>ScriptableObjects, image files and UI Image, from <a href="https://forum.unity.com/threads/scriptableobjects-image-files-and-ui-image.886486/">https://forum.unity.com/threads/scriptableobjects-image-files-and-ui-image.886486/</a></p><h6 id="雪莉"><a href="#雪莉" class="headerlink" title="雪莉"></a>雪莉</h6><img src="https://cdn.jsdelivr.net/gh/z-hwa/webHomeImage/image/00000.png" width=30%/>]]></content>
    
    
    <categories>
      
      <category>Game-develope</category>
      
    </categories>
    
    
    <tags>
      
      <tag>turn-based RPG</tag>
      
      <tag>C#</tag>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 強化學習 AI 訓練-貪吃蛇</title>
    <link href="/webHome/%5Bobject%20Object%5D/2023/08/13/ai/Python-%E5%BC%B7%E5%8C%96%E5%AD%B8%E7%BF%92-AI-%E8%A8%93%E7%B7%B4-%E8%B2%AA%E5%90%83%E8%9B%87/"/>
    <url>/webHome/%5Bobject%20Object%5D/2023/08/13/ai/Python-%E5%BC%B7%E5%8C%96%E5%AD%B8%E7%BF%92-AI-%E8%A8%93%E7%B7%B4-%E8%B2%AA%E5%90%83%E8%9B%87/</url>
    
    <content type="html"><![CDATA[<h1 id="Python-強化學習-AI-訓練-貪吃蛇"><a href="#Python-強化學習-AI-訓練-貪吃蛇" class="headerlink" title="Python 強化學習 AI 訓練-貪吃蛇"></a>Python 強化學習 AI 訓練-貪吃蛇</h1><img src="https://cdn.jsdelivr.net/gh/z-hwa/webHomeImage/image/snake%20game.PNG"/><h2 id="資料"><a href="#資料" class="headerlink" title="資料"></a>資料</h2><blockquote><p>計算機概論 期末專題<br>作者：王冠章<br>學號：C14116132<br>Github 連結：<a href="https://github.com/z-hwa/AITraining">https://github.com/z-hwa/AITraining</a></p></blockquote><div class="code-wrapper"><pre><code class="hljs">目錄一、摘要二、開發環境三、主要套件四、遊戲本體五、AI 實現六、模型訓練成效七、操作與介面說明八、專案總結九、未來規劃十、參考資料</code></pre></div><h2 id="一、摘要："><a href="#一、摘要：" class="headerlink" title="一、摘要："></a>一、摘要：</h2><p>利用 python 中的 pygame 套件，先實作貪吃蛇遊戲，完成玩家操控的部分。接著完成 AI 的 agent 對於遊戲操控、收集遊戲中資料的程式碼。最後，透過 pytorch 中的 Linear 實現模型的訓練框架，以及 optim 來優化 AI訓練對於獎勵獲取的算法。也實作了操作介面，方便 AI 訓練的操作以及實際測試。</p><h2 id="二、開發環境："><a href="#二、開發環境：" class="headerlink" title="二、開發環境："></a>二、開發環境：</h2><p>Pycharm<br>Powewshell 7.6<br>github<br>Python3.7<br>Pytorch with cpu<br>Conda</p><h2 id="三、主要套件："><a href="#三、主要套件：" class="headerlink" title="三、主要套件："></a>三、主要套件：</h2><p>Pygame<br>matplotlib ipython<br>numpy</p><h2 id="四、遊戲本體："><a href="#四、遊戲本體：" class="headerlink" title="四、遊戲本體："></a>四、遊戲本體：</h2><p>貪吃蛇遊戲本體的實現，是由數個函數來完成，以下說明與 AI 較為相關的數個。</p><h4 id="一-Reset"><a href="#一-Reset" class="headerlink" title="(一) Reset"></a>(一) Reset</h4><blockquote><p>用於初始化遊戲的資料設定，如蛇的數據、食物、分數等等資訊。<br>之所以不寫在 init 中的原因是，AI 訓練時會需要反覆開啟遊戲的<br>新局，因此可以直接呼叫此函數。</p></blockquote><h4 id="二-play-step"><a href="#二-play-step" class="headerlink" title="(二) _play_step"></a>(二) _play_step</h4><blockquote><p>除了作為玩家輸入之外，在 AI 訓練中，將改為從模型中取得輸<br>出。而因為遊戲的進行是基於玩家的操控，在此函數中，同時呼叫<br>是否發生碰種、移動、ui 更新的函數。</p></blockquote><h4 id="三-move"><a href="#三-move" class="headerlink" title="(三) _move"></a>(三) _move</h4><blockquote><p>移動的實現是透過計算蛇頭的下一個位置，並在 list 中插入。而<br>原先的尾巴則會被清掉。在更新 UI 時，透過 pygame 根據 list 中<br>的座標去繪製方塊，形成蛇的移動。</p></blockquote><h2 id="五、AI-實現："><a href="#五、AI-實現：" class="headerlink" title="五、AI 實現："></a>五、AI 實現：</h2><p>關於參考資料中的模型，包含 11 個輸入層、256 個隱藏層、3 個輸出層。11 個輸入層的資料分別為</p><blockquote><p>(一) 轉向是否會產生碰種，包含左轉、右轉、不轉。<br>(二) 頭部相鄰的四個方格，是否存在障礙物。<br>(三) 食物的位置是在上下左右哪個方位。</p></blockquote><p>這些資料都是 0 或 1 的整數型資料。而輸出層則會輸出 3 個浮點數，並從這三個浮點數中，取出最大值，作為貪吃蛇行動的根據，包括：左轉、右轉、不轉。</p><p>而模型則透過 Q learning 來訓練，第一步會透過現在的狀態去預測 Q值，執行動作，計算獎勵，最後計算出新的 Q 值。從代碼實現的角度來看，我們最終會得到一個動作回數*3 行動可能的 Q 值表，並利用 pytorch寫好的優化函數，來幫我們更新模型的參數。如下</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 1. 透過現在的狀態去預測Q值</span>pred = self.model(state)<span class="hljs-comment"># 2. Q_new = r + y * max(next_predicted Q value)    -&gt;  only do this if not done</span><span class="hljs-comment"># pred.clone()</span><span class="hljs-comment"># preds[argmax(action)] = Q_new</span>target = pred.clone()  <span class="hljs-comment"># 複製前面的預測</span><span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(done)):    Q_new = reward[idx]  <span class="hljs-comment"># 預設新的Q值為當前編號的reward</span>    <span class="hljs-comment"># 如果done為false(遊戲還沒結束，可以預測下一個行動)</span>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> done[idx]:        Q_new = reward[idx] + self.gamma * torch.<span class="hljs-built_in">max</span>(self.model(next_state[idx]))  <span class="hljs-comment"># 藉由公式計算新的Q值</span>    target[idx][torch.argmax(action).item()] = Q_new  <span class="hljs-comment"># 將運測中行動可能性最高的設為新的Q值</span></code></pre></div><p>代碼中有一個數值叫做 gamma，實際上代表的是折扣率，介於 0~1 之間。用於讓 AI 能夠判斷是要更關注未來(數值高)還是現在的獎勵(數值低)。</p><p>而在 AI 訓練時，最終的行動決策上，則取決於 epsilon 以及 random 的比較，來決定這一次的行動是隨機發生，或著是由 AI 模型的預測結果去進行。隨著訓練局數的增加，將降低隨機選擇動作的機率，來優化 AI 模型的精準度。</p><h2 id="六、模型訓練成效："><a href="#六、模型訓練成效：" class="headerlink" title="六、模型訓練成效："></a>六、模型訓練成效：</h2><p>可以在recode_model_train中查看訓練的模型紀錄，並在model中找到對應的AI模型；figure中找到對應的訓練圖表。在更新舊模型訓練後，進行訓練的AI模型，可以在data中找到當時的訓練資料。</p><h5 id="一-參考資料模型配置："><a href="#一-參考資料模型配置：" class="headerlink" title="(一)參考資料模型配置："></a>(一)參考資料模型配置：</h5> <img src="https://cdn.jsdelivr.net/gh/z-hwa/webHomeImage/image/250AI%20Score.png"/> <p>圖二、訓練250回左右的AI得分圖表</p> <img src="https://cdn.jsdelivr.net/gh/z-hwa/webHomeImage/image/500AI%20Score.png"/> <p>圖三、訓練500回左右的AI得分圖表</p> <img src="https://cdn.jsdelivr.net/gh/z-hwa/webHomeImage/image/1300AI%20Score.png"/> <p>圖四、訓練1300回左右的AI得分圖表</p><p>以參考資料的訓練配置來看，比較訓練250回和500回之間的平均分(紅色曲線)，貪吃蛇AI在達到平均分22左右時，進步速度就不大明顯了。在經過更長時間(1300回)的訓練後，發現平均分有收斂於31左右的趨勢。推測原因是會出現身體長度過長，而將自己給圈住，導致遊戲失敗的情況。</p><h5 id="二-10節-30節身體座標配置："><a href="#二-10節-30節身體座標配置：" class="headerlink" title="(二)10節 &#x2F; 30節身體座標配置："></a>(二)10節 &#x2F; 30節身體座標配置：</h5><p>由於上述失敗原因，我預期能夠透過輸入每節身體的位置，來使AI能夠知道自己的頭部不應該出現被身體圈住的情況。</p><p>在這裡的模型配置，以添加了10節身體的xy座標模型為例。因為前11個參數的大小介於0<del>1之間，這裡我也將xy座標除以遊戲視窗長寬，以確保所有參數都介於0</del>1之間。因此，這個模型的輸入有31層。</p><p>而因為輸入層的增加，有必要提升epsilon的大小以確保，AI有足夠的時間從亂數中，學習到正確的行為模式。而新的epsilon設為7*輸入層數，目的是確保所有模型的epsilon和輸入層之間是接近正比。</p><p>除此之外，我也設置了每個移動-0.01的懲罰，以避免AI在理解不能碰撞身體後，選擇不斷原地繞圈的行為。(根據訓練日誌中b~f的最終訓練成果)</p> <img src="https://cdn.jsdelivr.net/gh/z-hwa/webHomeImage/image/10%20body%20train.png"/> <p>圖五、10節身體位置的訓練配置</p> <img src="https://cdn.jsdelivr.net/gh/z-hwa/webHomeImage/image/30body%20train.png"/> <p>圖六、30節身體位置的訓練配置</p><p>在經過更大量的訓練回數後，觀察到訓練圖表的平均分數收斂在20以及25左右。根據對AI實際行為的觀察，可以發現AI似乎沒有理解身體位置的數據。主要原因可能為AI的主要行為模式基於參考配置的11種輸入，都是一種方向上的相對概念。同時，AI所能做出的行動(轉動蛇頭方向)，也是方向相對概念的一種。因此要理解座標上的數據，相對困難。</p><h5 id="三-射線檢測器"><a href="#三-射線檢測器" class="headerlink" title="(三)射線檢測器"></a>(三)射線檢測器</h5><p>基於上個訓練配置最終的推測，這次我在蛇頭放置射線檢測器，功能是延伸向四個方向，偵測是否有撞到自己的身體，以及這個距離是多長。預期的效果仍是，避免AI撞到自己的身體。<br>模型的輸入層增加8個，前四個代表是否偵測到身體；後四個為這個距離是多少個格子。Epsilon則依舊以正比增加。但這次不給予步數懲罰，原因是有的時候為了不把自己困住，可能會出現需要繞路的情況。(根據訓練日誌中f10, f30的訓練結果)</p> <img src="https://cdn.jsdelivr.net/gh/z-hwa/webHomeImage/image/line%20detector.png"/> <p>圖七、加入射線檢測器</p><p>最終成果上，平均分數落在35左右，說明藉由射線檢測器的加入。的確能降低蛇被自己的身體困住的部分情況。而之所以無法得到更好的效果，可能因素為，存在部分情況是四面都有自己的身體，但死路是最長的情況。(假定蛇在該環境的行為模式為，選擇最長的方向走。原因是前期訓練中最長的方向，是死路的可能性低)。</p><h2 id="七、操作與介面說明："><a href="#七、操作與介面說明：" class="headerlink" title="七、操作與介面說明："></a>七、操作與介面說明：</h2><p>在專案中，撰寫了一份使用者介面的程式，可以選擇四種不同的模式，包含：1玩家遊玩、2模型AI遊玩、3模型AI訓練、4舊模型訓練。</p><p>相比起參考資料中的專案，透過這個介面可以快速操作模型的訓練以及測試。也能夠自動儲存訓練後的模型、數據資料以及訓練圖表。並在使用舊模型進行重複訓練時，重新載入環境以及訓練過的數據。有效提高生產力。</p><blockquote><p>專案下載步驟<br>(一)在github上clone整個資料夾下來，打開cmd進入snack-pygame的資料夾中。<br>(二)確保環境中裝有python、pytorch with cpu。以及pygame、matplotlib、numpy套件<br>(三)在終端機執行userinterface.py進入操作介面</p></blockquote><h2 id="八、專案總結："><a href="#八、專案總結：" class="headerlink" title="八、專案總結："></a>八、專案總結：</h2><blockquote><p>(一)具備使用python完成AI訓練的能力<br>(二)配置並使用不同的訓練資料以及參數進行訓練<br>(三)了解Q_Learning算法<br>(四)透過matplotlib套件，幫助訓練資料的可視化<br>(五)訓練模型以及資料的儲存、載入</p></blockquote><p>根據參考資料實作了AI訓練的一個小專題，理解每一行代碼的功能，並了解模型的創建，包括輸入層、隱藏層、輸出層。以及輸入資料應該如何去挑選，才能讓AI最終訓練的成果更好。並嘗試改進在參考資料中，訓練出來的AI模型會出現的問題。過程中，熟悉如何從遊戲擷取輸入資料，並載入到訓練模型。</p><p>這次的專案在最初改進時，存在一個廢案，為了降低輸入層的複雜度，透過記錄每一節身體的前一節位置來做訓練。但這種抽象資料卻會造成AI需要更大量的訓練才能明白數據的意義，後續捨棄。(根據訓練日誌中b~e的結果)</p><p>學習到關於Q_Learning算法中，如何計算新的Q值，並利用該值，來實現agent的操作。包含折扣率對於AI的影響、隨機行動的必要等等。</p><p>了解了如何去利用matplot，來幫助繪製AI訓練時的資料圖，以幫助分析AI訓練的獎勵值變化。而為了處理舊模型訓練的問題，也實現了關於資料之間的型態轉換、讀檔、存檔的功能。以方便後續訓練中，保證訓練資料的連續、訓練圖表的完整性。</p><h2 id="九、未來規劃："><a href="#九、未來規劃：" class="headerlink" title="九、未來規劃："></a>九、未來規劃：</h2><p>(一)嘗試不同以及更龐大的輸入資料，了解輸入資料和貪吃蛇AI成效之間的差異。並訓練出效果更好的貪吃蛇</p><p>(二)學習deep q learning用於改進AI訓練的成果</p><p>(三)學習生成對抗網路，並應用在此次專案中，訓練AI之間的競爭，以了解該種神經網路的實作。</p><h2 id="十、參考資料："><a href="#十、參考資料：" class="headerlink" title="十、參考資料："></a>十、參考資料：</h2><p>Teach AI To Play Snake - Reinforcement Learning Tutorial With PyTorch And Pygame, from <a href="https://youtu.be/5Vy5Dxu7vDs">https://youtu.be/5Vy5Dxu7vDs</a></p><p>pygame官方文檔，取自 <a href="https://www.pygame.org/docs/tut/PygameIntro.html">https://www.pygame.org/docs/tut/PygameIntro.html</a></p><p>机器学习9:关于pytorch中的zero_grad（）函數，取自 <a href="https://blog.csdn.net/weixin_39504171/article/details/103179067">https://blog.csdn.net/weixin_39504171/article/details/103179067</a></p><p>PyTorch使用GPU训练的两种方法实例，取自 <a href="https://www.jb51.net/article/248324.htm">https://www.jb51.net/article/248324.htm</a></p><p>PyTorch的nn.Linear（）详解，取自 <a href="https://blog.csdn.net/qq_42079689/article/details/102873766">https://blog.csdn.net/qq_42079689/article/details/102873766</a></p><p>【Day 23】 Google ML - Lesson 9 - 加速ML模型訓練的兩大方法(如何設定batch&#x2F;檢查loss頻率)、batch size, iteration, epoch的概念和比較，取自 <a href="https://ithelp.ithome.com.tw/articles/10219945">https://ithelp.ithome.com.tw/articles/10219945</a></p><p>30 天在 Colab 嘗試的 30 個影像分類訓練實驗，取自 <a href="https://ithelp.ithome.com.tw/users/20107299/ironman/4809">https://ithelp.ithome.com.tw/users/20107299/ironman/4809</a></p><p>并行化强化学习 —— 初探 —— 并行reinforce算法的尝试 （上篇：强化学习在多仿真环境下单步交互并行化设计的可行性），取自 <a href="https://www.cnblogs.com/devilmaycry812839668/p/14221576.html">https://www.cnblogs.com/devilmaycry812839668/p/14221576.html</a></p><p>手把手教你做一个强化学习的环境，用pygame搭建一个可视化训练游戏环境(一)，取自 <a href="https://blog.csdn.net/weixin_48174100/article/details/119242038">https://blog.csdn.net/weixin_48174100/article/details/119242038</a></p>]]></content>
    
    
    <categories>
      
      <category>AI-about</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>AI</tag>
      
      <tag>Pygame</tag>
      
      <tag>Reinforcement Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>testPage</title>
    <link href="/webHome/%5Bobject%20Object%5D/2023/08/08/testPage/"/>
    <url>/webHome/%5Bobject%20Object%5D/2023/08/08/testPage/</url>
    
    <content type="html"><![CDATA[<h1 id="用於測試網頁內容的頁面"><a href="#用於測試網頁內容的頁面" class="headerlink" title="用於測試網頁內容的頁面"></a>用於測試網頁內容的頁面</h1><h1 id="數學式測試"><a href="#數學式測試" class="headerlink" title="數學式測試"></a>數學式測試</h1><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.985ex;" xmlns="http://www.w3.org/2000/svg" width="4.653ex" height="2.942ex" role="img" focusable="false" viewBox="0 -864.9 2056.8 1300.3" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path id="MJX-1-TEX-I-1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path><path id="MJX-1-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path id="MJX-1-TEX-N-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mfrac"><g data-mml-node="mn" transform="translate(851.6,394) scale(0.707)"><use data-c="31" xlink:href="#MJX-1-TEX-N-31"></use></g><g data-mml-node="mrow" transform="translate(220,-377.4) scale(0.707)"><g data-mml-node="msup"><g data-mml-node="mi"><use data-c="1D465" xlink:href="#MJX-1-TEX-I-1D465"></use></g><g data-mml-node="mn" transform="translate(605,289) scale(0.707)"><use data-c="32" xlink:href="#MJX-1-TEX-N-32"></use></g></g><g data-mml-node="mo" transform="translate(1008.6,0)"><use data-c="2212" xlink:href="#MJX-1-TEX-N-2212"></use></g><g data-mml-node="mn" transform="translate(1786.6,0)"><use data-c="31" xlink:href="#MJX-1-TEX-N-31"></use></g></g><rect width="1816.8" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/webHome/%5Bobject%20Object%5D/2023/08/07/hello-world/"/>
    <url>/webHome/%5Bobject%20Object%5D/2023/08/07/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span></code></pre></div><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo server</code></pre></div><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo generate</code></pre></div><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo deploy</code></pre></div><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>UI設計及即時生成瀏覽效果-語言記憶</title>
    <link href="/webHome/%5Bobject%20Object%5D/2021/10/17/game-develope/UI%E8%A8%AD%E8%A8%88%E5%8F%8A%E5%8D%B3%E6%99%82%E7%94%9F%E6%88%90%E7%80%8F%E8%A6%BD%E6%95%88%E6%9E%9C-%E8%AA%9E%E8%A8%80%E8%A8%98%E6%86%B6/"/>
    <url>/webHome/%5Bobject%20Object%5D/2021/10/17/game-develope/UI%E8%A8%AD%E8%A8%88%E5%8F%8A%E5%8D%B3%E6%99%82%E7%94%9F%E6%88%90%E7%80%8F%E8%A6%BD%E6%95%88%E6%9E%9C-%E8%AA%9E%E8%A8%80%E8%A8%98%E6%86%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="UI設計及即時生成瀏覽效果-語言記憶"><a href="#UI設計及即時生成瀏覽效果-語言記憶" class="headerlink" title="UI設計及即時生成瀏覽效果-語言記憶:"></a>UI設計及即時生成瀏覽效果-語言記憶:</h1><h2 id="Author"><a href="#Author" class="headerlink" title="Author:"></a>Author:</h2><ul><li>Z-hwA</li></ul><h2 id="github連結"><a href="#github連結" class="headerlink" title="github連結"></a>github連結</h2><ul><li><a href="https://github.com/z-hwa/Unity_Game_About">點這裡</a></li></ul><h2 id="一-概要"><a href="#一-概要" class="headerlink" title="(一) 概要:"></a>(一) 概要:</h2><p>基本功能包括，手動輸入單字卡、建立單字卡倉庫，單字卡測驗、單字卡即時生成等等。其中遇上各種UI設計，坐標軸的設定、中文字顯示模糊等問題。後續透過資料查詢一一解決。並在單字卡顯示上，不使用Unity的滑動視窗一次性大量生成，而是透過代碼，即時生成，以降低手機端效能浪費問題的可能性。<br><img src="https://i.imgur.com/u6aAXnQ.png"><br> (圖一) 語言記憶基礎介面。</p><h2 id="二-使用方式"><a href="#二-使用方式" class="headerlink" title="(二) 使用方式:"></a>(二) 使用方式:</h2><p>直接輸入單字，並選擇儲存的倉庫，儲存，即可生成單字卡。透過測試，可選擇測試的倉庫、單字數、外語對母語、母語對外語等設定，進行測試。倉庫中能夠翻閱以儲存的單字，並確認答對率。</p><h2 id="三-UI介面"><a href="#三-UI介面" class="headerlink" title="(三) UI介面:"></a>(三) UI介面:</h2><p>在基礎UI上，選擇Scale With Screen Size，以確保整體畫布自適應螢幕大小，內層加入橫向滑動視窗，以切換不同頁面。</p><p>字體模糊問題上，有兩種處理方式，一是自行添加中文字庫，二是將字體大小設置極大，在透過Rect Transform將Scale設置極小，以達到清晰化的目的。由於字庫一次匯入字數有限，過多會使的字體同樣不清晰，加上無法確保所有字都存在其中。最終選擇第二種方案。<br><img src="https://i.imgur.com/NSRLPxe.png"></p><p> (圖二) 字體模糊問題解決方案。</p><p>倉庫方面，面對的問題是無法達成，依照版面生成Prefers的效果，最終只能設置固定的位置點，在建立倉庫指令後，於固定的位置點生成，亦無法做到刪除倉庫的動作。最終，在倉庫中提供重新命名以解決這個問題。<br><img src="https://i.imgur.com/Uhp15nH.png"></p><p> (圖三) 倉庫介面。</p><h2 id="四-資料儲存與添加方式"><a href="#四-資料儲存與添加方式" class="headerlink" title="(四) 資料儲存與添加方式:"></a>(四) 資料儲存與添加方式:</h2><p>透過json的方式做資料的儲存。在單字和倉庫的儲存上面，將單字陣列存在倉庫陣列裡面，需要載入時，轉成List之後，再添加回去。在單字、倉庫的建立上，也是先將陣列轉為List之後，添加完再載入回陣列。</p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-number">1.</span><span class="hljs-comment">//轉成List添加單字</span><span class="hljs-number">2.</span>            List&lt;Struct.wordMode&gt; tem = <span class="hljs-keyword">new</span> List&lt;Struct.wordMode&gt;(Store.instance.<span class="hljs-keyword">group</span>[storeIndex].word);<span class="hljs-number">3.</span>            Struct.wordMode word;<span class="hljs-number">4.</span>            tem.Add(word);<span class="hljs-number">5.</span><span class="hljs-number">6.</span>            <span class="hljs-comment">//轉回去</span><span class="hljs-number">7.</span>            Store.instance.<span class="hljs-keyword">group</span>[storeIndex].word = tem.ToArray();</code></pre></div><p>(圖四) List轉換Array(Word_Memory_App\Assets\Scripts\BasicSystem.cs) (完整程式碼可在附錄的遊戲檔中取得。以下省略，僅保留程式碼路徑)。</p><h2 id="五-單字即時生成效果"><a href="#五-單字即時生成效果" class="headerlink" title="(五) 單字即時生成效果:"></a>(五) 單字即時生成效果:</h2><p>透過判定單字展示頁面，經手指滑動後的位置，確認從上方或下方新增單字。接著，刪除相反方向的單字卡物件，同時，啟動生成單字的函式，生成單字的函式，則在應該生成單字的位置，生成下一個單字。<br>            <img src="https://i.imgur.com/gYJtye6.png"></p><p>(圖五) 單字展示頁面，紅框中為鎖定單字滑條。</p><p>而左上角滑條，鎖定特定序號的單字功能。則是根據鎖定單字的序號，比較當前狀況，將單字顯示頁面的位置，鎖定成接收到手指滑動的狀態，使程式進入上一個程序中。</p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-number">1.</span>        <span class="hljs-comment">//發現單字數不足，自動生成單字</span><span class="hljs-number">2.</span>        <span class="hljs-keyword">if</span> (wordNum &gt; <span class="hljs-number">0</span> &amp;&amp; word.Length &lt; <span class="hljs-number">6</span> &amp;&amp; Store.instance.<span class="hljs-keyword">group</span>[groupIndex].word.Length &gt; nowWord)<span class="hljs-number">3.</span>        &#123;<span class="hljs-number">4.</span>            CreateWord();<span class="hljs-number">5.</span>        &#125;<span class="hljs-number">6.</span><span class="hljs-number">7.</span>        <span class="hljs-comment">//向下滑動，動態新增</span><span class="hljs-number">8.</span>        <span class="hljs-keyword">if</span>(content.GetComponent&lt;RectTransform&gt;().position.y &gt;= (posContent.y + <span class="hljs-number">100f</span>) &amp;&amp; wordNum &gt; <span class="hljs-number">0</span> &amp;&amp; Store.instance.<span class="hljs-keyword">group</span>[groupIndex].word.Length &gt; nowWord &amp;&amp; time &gt;= timeSet)<span class="hljs-number">9.</span>        &#123;<span class="hljs-number">10.</span>            time = <span class="hljs-number">0f</span>;<span class="hljs-number">11.</span>            mode = <span class="hljs-number">0</span>;<span class="hljs-number">12.</span>            <span class="hljs-comment">//Debug.Log(content.GetComponent&lt;RectTransform&gt;().position.y + &quot;下方&quot; + wordPos[2].transform.position.y);</span><span class="hljs-number">13.</span><span class="hljs-number">14.</span>            <span class="hljs-comment">//刪除物件</span><span class="hljs-number">15.</span>            Destroy(word[<span class="hljs-number">0</span>].gameObject);<span class="hljs-number">16.</span><span class="hljs-number">17.</span>            <span class="hljs-comment">//轉成List刪除</span><span class="hljs-number">18.</span>            List&lt;GameObject&gt; tem = <span class="hljs-keyword">new</span> List&lt;GameObject&gt;(word);<span class="hljs-number">19.</span>            tem.RemoveAt(<span class="hljs-number">0</span>);<span class="hljs-number">20.</span><span class="hljs-number">21.</span>            <span class="hljs-comment">//轉回去</span><span class="hljs-number">22.</span>            word = tem.ToArray();<span class="hljs-number">23.</span>            <span class="hljs-comment">//Debug.Log(word.Length);</span><span class="hljs-number">24.</span>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;word.Length;i++)<span class="hljs-number">25.</span>            &#123;<span class="hljs-number">26.</span>                <span class="hljs-comment">//Debug.Log(i);</span><span class="hljs-number">27.</span>                word[i].gameObject.transform.position = <span class="hljs-keyword">new</span> Vector2(wordPos[i].transform.position.x, wordPos[i].transform.position.y);<span class="hljs-number">28.</span>            &#125;<span class="hljs-number">29.</span>        &#125;</code></pre></div><p>(圖六) 單字即時生成判定(Word_Memory_App\Assets\Scripts\WordShow.cs)。</p><h2 id="六-單字測驗相關"><a href="#六-單字測驗相關" class="headerlink" title="(六) 單字測驗相關:"></a>(六) 單字測驗相關:</h2><p>在單字測驗中，目前為透過基本的隨機函數生成測驗單字及選項，而在測驗結束後，則會顯示測驗單字的資料，基本上與單字顯示頁面相同，但會額外標註對錯，並更新資料中的答對率等。</p><p>   <img src="https://i.imgur.com/PQKClbj.png"><br><img src="https://i.imgur.com/nf5ywJa.png"><br><img src="https://i.imgur.com/uolQWGu.png"></p><p>(圖七、八、九) 單字測驗相關圖片</p><h2 id="七-APP建置"><a href="#七-APP建置" class="headerlink" title="(七) APP建置:"></a>(七) APP建置:</h2><p>設定輸出為.aab檔，設置相關的名稱等資料，API設定為當前最高級別，藉由IL2CPP模式編譯，用APM64的架構，設定金鑰後就能夠build。最終在開通Google Play帳號後，就能夠上傳。</p><h2 id="八-相關資料"><a href="#八-相關資料" class="headerlink" title="(八) 相關資料:"></a>(八) 相關資料:</h2><p>一、 遊戲相關<br>    <a href="https://github.com/newmaker-plus0/Unity_Game_About">遊戲檔案(github)</a>: 其中包含app的項目、開發日誌。<br>    <a href="https://play.google.com/store/apps/details?id=com.OnlyHigher.THMA_The_Word_Memory_App">語言記憶APP(google play商店)</a>: 上傳在google play上的應用。</p><p>二、 參考資料:</p><ul><li><p>下拉選單<br><a href="https://docs.unity3d.com/cn/2018.4/Manual/script-Dropdown.html">下拉选单 (Dropdown)</a><br><a href="https://blog.csdn.net/YuAFa/article/details/52838215?utm_medium=distribute.pc_relevant.none-task-blog-searchFromBaidu-3.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-searchFromBaidu-3.control">UGUI Dropdown控件的大小设置</a><br><a href="https://www.cnblogs.com/stan-si/p/7459368.html">Unity控件ScrollView使用问题记录</a><br>  <a href="https://blog.csdn.net/Czhenya/article/details/93669979">Unity 之 UGUI Dropdown组件使用简析</a><br>  <a href="https://blog.csdn.net/oncruise/article/details/95988493">Dropdown.onValueChanged()</a></p></li><li><p>手機遊戲建置<br><a href="https://medium.com/@grass527/unity-%E9%96%8B%E7%99%BCandroid%E6%89%8B%E6%A9%9F%E9%81%8A%E6%88%B22020%E5%BB%BA%E7%BD%AE%E8%A8%AD%E5%AE%9A-9487a4e2c0e6">Unity 開發Android手機遊戲建置設定2020 (Google Play)</a><br><a href="https://www.gameislearning.url.tw/article_content.php?getb=24&foog=9997">Unity Android 發佈(輸出apk檔)設定及手機安裝教學</a></p></li><li><p>滑動翻頁<br>  <a href="https://www.bilibili.com/video/av372081476/">Unity UGUI实现滑动翻页效果</a><br><a href="https://docs.unity3d.com/cn/2018.4/Manual/script-ScrollRect.html">滚动矩形 (Scroll Rect)</a></p></li><li><p>畫面模糊<br>  <a href="https://forum.gamer.com.tw/C.php?bsn=60602&snA=3086">【問題】想請教一下，在輸出到手機後圖片會失真的問題</a></p></li><li><p>輸入<br>  <a href="https://blog.csdn.net/jjk_by/article/details/79716310">Unity inputField 没办法换行 问题</a><br>  <a href="https://zhidao.baidu.com/question/1544483398124249307.html">想问一下Unity的UI中怎样用脚本获取InputField的值？</a></p></li><li><p>字體<br>  <a href="https://zhuanlan.zhihu.com/p/84700094">Unity游戏开发——TextMeshPro的使用</a></p></li><li><p>動態新增元素<br>  <a href="https://blog.csdn.net/qq_35938548/article/details/78325558">C#中如何向数组中动态添加元素</a><br>  <a href="https://www.itread01.com/content/1541928562.html">C#陣列 動態新增元素</a></p></li><li><p>Array<br>  <a href="https://blog.csdn.net/tanmengwen/article/details/19498263">Unity3D教程：Array数组类的使用</a></p></li><li><p>預製體<br>  <a href="https://blog.csdn.net/qq_39108767/article/details/82229000">【Unity】Prefab预设体及取消关联</a></p></li><li><p>事件<br>  <a href="https://blog.csdn.net/iFasWind/article/details/82352042">[Unity 3D] EventSystem的简单介绍和使用</a><br>  <a href="https://blog.csdn.net/Czhenya/article/details/86629410">Unity 之UGUI InputField 组件的使用</a></p></li><li><p>子物件修改<br>  <a href="https://www.itread01.com/content/1548685265.html">unity程式碼修改子物體層級的順序</a></p></li><li><p>List<br>  <a href="https://blog.csdn.net/piyixia/article/details/87916045">Unity中list使用</a></p></li><li><p>儲存<br>  <a href="https://docs.microsoft.com/zh-tw/dotnet/api/system.io.streamreader.readline?view=net-5.0">StreamReader.ReadLine 方法</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Game-develope</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>A*及射線檢測運用-激光與子彈</title>
    <link href="/webHome/%5Bobject%20Object%5D/2021/10/11/game-develope/A-%E5%8F%8A%E5%B0%84%E7%B7%9A%E6%AA%A2%E6%B8%AC%E9%81%8B%E7%94%A8-%E6%BF%80%E5%85%89%E8%88%87%E5%AD%90%E5%BD%88/"/>
    <url>/webHome/%5Bobject%20Object%5D/2021/10/11/game-develope/A-%E5%8F%8A%E5%B0%84%E7%B7%9A%E6%AA%A2%E6%B8%AC%E9%81%8B%E7%94%A8-%E6%BF%80%E5%85%89%E8%88%87%E5%AD%90%E5%BD%88/</url>
    
    <content type="html"><![CDATA[<h1 id="A-及射線檢測運用-激光與子彈"><a href="#A-及射線檢測運用-激光與子彈" class="headerlink" title="A*及射線檢測運用-激光與子彈:"></a>A*及射線檢測運用-激光與子彈:</h1><h2 id="Author"><a href="#Author" class="headerlink" title="Author:"></a>Author:</h2><ul><li>Z-hwA</li></ul><h2 id="github連結"><a href="#github連結" class="headerlink" title="github連結"></a>github連結</h2><ul><li><a href="https://github.com/z-hwa/Unity_Game_About">點這裡</a></li></ul><h2 id="一-概要"><a href="#一-概要" class="headerlink" title="(一)概要"></a>(一)概要</h2><p>在開發這款遊戲前，我心想要製作一款射擊類遊戲，因此我研究了有關於射線的內容。此外，由於射擊類遊戲，我在地圖上新增了一些地形。因為這個原因，像是無限繼承中的簡單敵人AI就沒辦法做到追蹤玩家，而是會被地形卡住。所以，我搜尋了有關於敵人AI尋路的功能，最後決定使用A*來實作。</p><p>同樣的，為了使遊戲具有可玩性，我依舊添加了無限波數的系統。只是這次我想在強化方式上，做出一些改變，從隨機的強化，進入到有規則、有策略性的強化。以及加入更多RPG元素。</p><p>因此，我選擇了升級系統，透過擊敗敵人來獲得經驗值，從而升級。升級後，獲得技能點，進行天賦加點。透過這樣的方式來強化玩家。</p><p>不同於上一款遊戲的部分則是，我將Buff系統安裝到了敵人的身上，在每次敵人生成時，隨機給予特定數量的特定Buff，以此提升遊戲的隨機性，以及挑戰性。其中包含:普通武器免疫、能量武器免疫、巨大化等。</p><p>至於這款遊戲的核心，槍戰系統。我採用子彈數的方式來實現，總共有數種不同的槍可供使用，這些槍都有子彈數限制，子彈則可透過擊殺敵人隨機掉落。用意除了限制玩家的火力外，也是想使遊戲更有難度。可是不同於普通槍戰遊戲的點是，我添加了使用能量的武器，這種武器的能量用光後會自動回復。以及次元武器，這種武器消耗的是儲備的次數，但也會隨著時間回復。</p><h2 id="二-遊戲玩法"><a href="#二-遊戲玩法" class="headerlink" title="(二)遊戲玩法"></a>(二)遊戲玩法</h2><p>透過WASD移動腳色，鼠標瞄準，鼠標左鍵射擊、鼠標右鍵手刀。並透過E、R、T、Y、G、H可進行武器切換，按下P鍵可暫停遊戲。</p><p>在天賦樹頁面，可以將現有天賦點進行分配，只是目前只有啟動武器的幾個天賦，以及一些強化而已。</p><p>敵人則有危險度分級，從低到高分別是:白、綠、藍、紅、金、黑，分別代表敵人身上持有的Buff數量，從零到五。</p><h2 id="三-子彈功能實裝"><a href="#三-子彈功能實裝" class="headerlink" title="(三)子彈功能實裝"></a>(三)子彈功能實裝</h2><p>在這款遊戲中，我實裝了無限繼承中提到的追蹤彈功能。此外，也設計了四種不同的槍械，透過調整子彈的發射時間，以及速度、顏色、傷害等，分成了四種:步槍、加特林(機槍)、散彈槍、狙擊槍。</p><p>以及作為次元武器的次元跳躍，只要鎖定某個定點後，便能在數秒後，出現在那個位置。可以透過連續使用，做到花式操作的感覺。只是因為這個功能而出現了能出現在牆中以及場地外的BUG。目前暫時未處理。</p><p> <img src="https://i.imgur.com/V82eYJ6.png"></p><p>(圖二十五)遊戲畫面以及武器欄</p><p>實際的代碼部分，則可在底下的路徑中找到。<br>槍械設計相關代碼:<br>(Ray Game\Assets\Scripts\Weapon.cs)</p><h2 id="四-射線檢測-激光"><a href="#四-射線檢測-激光" class="headerlink" title="(四)射線檢測_激光"></a>(四)射線檢測_激光</h2><p>在開發之前，我便決定要學習的功能其實是射線檢測。不論是作為平台類遊戲中，玩家跳躍時是否落到地面的判斷，或是檢測玩家是否接觸到可拾取物體的判斷。都能用射線檢測完成。</p><p>透過教學影片，我簡單的了解了有關射線檢測的內容。在教學影片中，將射線檢測放置在怪物身上，並讓怪物在定點來回移動。因為我覺得這樣的話難度太低，所以改造了一下，將怪物的激光實時對準玩家的所在地，並讓怪物追蹤玩家。<br> <img src="https://i.imgur.com/46wNTP7.png"></p><p>(圖二十六)怪物激光效果</p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-number">1.</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Detect</span>()  </span><span class="hljs-function">2.</span>    &#123;  <span class="hljs-number">3.</span>        RaycastHit2D hitInfo = Physics2D.Raycast(firePoint.position, target.position - <span class="hljs-keyword">this</span>.transform.GetChild(<span class="hljs-number">0</span>).position, maxDist); <span class="hljs-comment">//獲取射線命中物  </span><span class="hljs-number">4.</span>             <span class="hljs-number">5.</span>        <span class="hljs-keyword">if</span>(hitInfo.collider != <span class="hljs-literal">null</span> &amp;&amp; shoot == <span class="hljs-literal">true</span>) <span class="hljs-comment">//開啟射擊模式，且目標不為空  </span><span class="hljs-number">6.</span>        &#123;  <span class="hljs-number">7.</span>            <span class="hljs-keyword">if</span>(hitInfo.collider.tag == <span class="hljs-string">&quot;Wall&quot;</span>)  <span class="hljs-number">8.</span>            &#123;  <span class="hljs-number">9.</span>                <span class="hljs-comment">//Debug.DrawLine(firePoint.position, hitInfo.point, Color.green);  </span><span class="hljs-number">10.</span>  <span class="hljs-number">11.</span>                lineRenderer.SetPosition(<span class="hljs-number">1</span>, hitInfo.point);  <span class="hljs-number">12.</span>                lineRenderer.colorGradient = greenColor;  <span class="hljs-number">13.</span>            &#125;  <span class="hljs-number">14.</span>            <span class="hljs-keyword">if</span> (hitInfo.collider.tag == <span class="hljs-string">&quot;Player&quot;</span>)  <span class="hljs-number">15.</span>            &#123;  <span class="hljs-number">16.</span>                <span class="hljs-comment">//Debug.DrawLine(firePoint.position, hitInfo.point, Color.red);  </span><span class="hljs-number">17.</span>  <span class="hljs-number">18.</span>                lineRenderer.SetPosition(<span class="hljs-number">1</span>, hitInfo.point);  <span class="hljs-number">19.</span>                lineRenderer.colorGradient = redColor;  <span class="hljs-number">20.</span>  <span class="hljs-number">21.</span>                GameObject.Find(<span class="hljs-string">&quot;Player&quot;</span>).SendMessage(<span class="hljs-string">&quot;Hurt&quot;</span>); <span class="hljs-comment">//命中玩家  </span><span class="hljs-number">22.</span>            &#125;  <span class="hljs-number">23.</span>  <span class="hljs-number">24.</span>            <span class="hljs-comment">//Instantiate(hitEffect, hitInfo.point, Quaternion.identity); //生成爆炸效果  </span><span class="hljs-number">25.</span>            lineRenderer.SetPosition(<span class="hljs-number">0</span>, firePoint.position);  <span class="hljs-number">26.</span>        &#125;  <span class="hljs-number">27.</span>    &#125;</code></pre></div><p>(圖二十七)射線檢測部分代碼(Ray Game\Assets\Scripts\FireElement.cs)</p><p>在完成怪物部分的激光後，我開始嘗試在玩家身上增加激光武器，但不知道為何，機光束總是不能鎖定在玩家和鼠標之間，有時會偏移，有時會隨機旋轉。當時，我查了許多教學，只能大概知道是座標(世界座標或本地座標)轉換之間的問題，卻沒辦法解決這個問題。最後只能放棄。</p><h2 id="五-敵人AI升級-A-尋路"><a href="#五-敵人AI升級-A-尋路" class="headerlink" title="(五)敵人AI升級_A*尋路"></a>(五)敵人AI升級_A*尋路</h2><p>我這次將敵人的AI升級，其原因是場地上出現了障礙物，因此簡單的追蹤玩家無法成功。在查找一些資料後，我選擇使用A*提供的尋路功能，能透過簡單的設定，完成地圖的配置，使敵人依著設定，走在沒有障礙物的路上，並朝著玩家前進。</p><p> <img src="https://i.imgur.com/Sn0HtTC.png"></p><p>(圖二十八)A*底下的地圖設定</p><h2 id="六-存檔機制"><a href="#六-存檔機制" class="headerlink" title="(六)存檔機制"></a>(六)存檔機制</h2><p>在無限繼承中提到過PlayerPrefs的儲存方式，但在這款遊戲中，我使用了其他的存檔方式。最一開始我嘗試著使用的是JSON的序列化方式，但因為存在BUG始終無法解決，我最終改用二進制的方式儲存。</p><p>從實作來看，二進制和JSON的實作較為相似，但XML有明顯的不同，至於PlayerPrefs則完全不一樣。值得一提的是，因為我的天賦樹是透過scriptableObject來儲存，因此當我想在遊戲中，儲存升級後的技能點，並在天賦樹介面同步時，會出現問題。在查詢完相關資料後，似乎是因為沒有激活的原因。於是在存檔機制上，我後來設計為不同的場景使用不同的存檔區塊。</p><p>在修正過程中，其實也有犯過蠢，比如說在數據改變時，重新儲存一次檔案。只是在那個時候，遊戲中的數據已經被初始化了，導致那份存檔除了修改過的數據外，其他全都是初始化的結果。當時卡了蠻久的。</p><p>存檔機制實作:<br>(Ray Game\Assets\Scripts\PlayerUI.cs)</p><h2 id="七-天賦樹系統"><a href="#七-天賦樹系統" class="headerlink" title="(七)天賦樹系統"></a>(七)天賦樹系統</h2><p>最後，是這款遊戲的核心之一，天賦樹系統，主要的設計是根據教學影片得來的，從建立scriptableObject做到在Unity中便可以直接設計天賦，簡單化天賦的管理相當於將資料庫實體化。</p><p>如果在製作無限繼承時，我便知道這個功能的話，我應該不會在程式碼中建立資料庫，而是改用scriptableObject來做。過程的確是較輕鬆，不論是資料處理還是應用，都能透過圖形化來處理。唯一的問題就是在存檔機制中提到的，未激活導致兩個場景之中，無法直接調用變數。</p><p>天賦模板:<br>(Ray Game\Assets\Scripts\SkillData.cs)</p><p>天賦樹系統:<br>(Ray Game\Assets\Scripts\SkillManager.cs)</p><p> <img src="https://i.imgur.com/wDNPZkQ.png"></p><p>(圖二十九)天賦樹系統</p>]]></content>
    
    
    <categories>
      
      <category>Game-develope</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基礎Unity-狐狸島</title>
    <link href="/webHome/%5Bobject%20Object%5D/2021/10/11/game-develope/%E5%9F%BA%E7%A4%8EUnity-%E7%8B%90%E7%8B%B8%E5%B3%B6/"/>
    <url>/webHome/%5Bobject%20Object%5D/2021/10/11/game-develope/%E5%9F%BA%E7%A4%8EUnity-%E7%8B%90%E7%8B%B8%E5%B3%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="基礎Unity-狐狸島"><a href="#基礎Unity-狐狸島" class="headerlink" title="基礎Unity-狐狸島:"></a>基礎Unity-狐狸島:</h1><h2 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h2><ul><li>Z-hwA</li></ul><h2 id="github連結"><a href="#github連結" class="headerlink" title="github連結"></a>github連結</h2><ul><li><a href="https://github.com/z-hwa/Unity_Game_About">點這裡</a></li></ul><h2 id="一-概要"><a href="#一-概要" class="headerlink" title="(一)概要:"></a>(一)概要:</h2><p>剛學習Unity時的作品，是一款2D遊戲，主要實現的內容包括:腳色操作、Tilemap、敵人簡易AI、UI介面、音效、燈光以及場景。在實作的過程中，了解如何使用Unity，並且輸出遊戲檔。</p><p> <img src="https://i.imgur.com/Xg4hWa0.png"></p><p>(圖一)狐狸島遊戲截圖。</p><h2 id="二-遊戲玩法"><a href="#二-遊戲玩法" class="headerlink" title="(二)遊戲玩法"></a>(二)遊戲玩法</h2><p>透過WASD來操控腳色移動，收集場上的櫻桃。唯一的難點在於最高處的那顆櫻桃，僅有一次機會可以得到它，最終目標是，走到最後的門，進入下一關。第二關並未製作完成。</p><h2 id="三-腳色操作"><a href="#三-腳色操作" class="headerlink" title="(三)腳色操作"></a>(三)腳色操作</h2><p>透過給予剛體，提供力量，給予玩家的物件移動的力，從而達到移動的目的。此外，也撰寫一個動畫控制的方法，作為玩家物件面朝哪個方向、跳躍、趴下時的動畫控制。</p><p>在跳躍上，設置一個檢測器，以確保玩家在地面，才可以進行跳躍，並限制為二段跳。而在碰觸到敵人時，設置一個擊退效果，以及受傷的動畫。此外，玩家死亡時，將場景重設，重新開始遊戲。</p><p>而如果目前玩家動畫為跳躍完的下落，且碰觸到敵人時，則透過OnTriggerEnter2D，將敵人消滅。</p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-number">1.</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Movement</span>()  </span><span class="hljs-function">2.</span>    &#123;  <span class="hljs-number">3.</span>        <span class="hljs-built_in">float</span> horizontalMove = Input.GetAxisRaw(<span class="hljs-string">&quot;Horizontal&quot;</span>);  <span class="hljs-number">4.</span>        <span class="hljs-built_in">float</span> facedircetion = Input.GetAxisRaw(<span class="hljs-string">&quot;Horizontal&quot;</span>);  <span class="hljs-number">5.</span>        rb.velocity = <span class="hljs-keyword">new</span> Vector2(horizontalMove*speed, rb.velocity.y);  <span class="hljs-number">6.</span>        anim.SetFloat(<span class="hljs-string">&quot;running&quot;</span>, Mathf.Abs(facedircetion));  <span class="hljs-number">7.</span>  <span class="hljs-number">8.</span>        <span class="hljs-comment">//腳色移動  </span><span class="hljs-number">9.</span>        <span class="hljs-keyword">if</span> (horizontalMove != <span class="hljs-number">0</span>)  <span class="hljs-number">10.</span>        &#123;  <span class="hljs-number">11.</span>            transform.localScale = <span class="hljs-keyword">new</span> Vector3(horizontalMove, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);  <span class="hljs-number">12.</span>        &#125;  <span class="hljs-number">13.</span>  <span class="hljs-number">14.</span>        <span class="hljs-comment">//腳色跳躍    </span><span class="hljs-number">15.</span>        Crouch();  <span class="hljs-number">16.</span>    &#125;</code></pre></div><p>(圖二)基本腳色移動程式碼 ( Sunnyland\Assets\Scripts\Player_Controller.cs) (完整程式碼可在附錄的遊戲檔中取得。以下省略，僅保留程式碼路徑)。</p><h2 id="四-Tilemap"><a href="#四-Tilemap" class="headerlink" title="(四)Tilemap"></a>(四)Tilemap</h2><p>透過Unity內建的Tilemap功能，可以輕鬆地建立一個2D像素化地圖，對於獨立遊戲開發者而言是非常有效益的選擇，因此我也使用了這樣的方式來創建我的地圖。此外，我亦給背景添加了不同的圖層，以達到豐富遊戲介面的效果。</p><p> <img src="https://i.imgur.com/QLAdc7n.png"></p><p>(圖三)使用Tilemap繪製地圖。</p><h2 id="五-敵人AI"><a href="#五-敵人AI" class="headerlink" title="(五)敵人AI"></a>(五)敵人AI</h2><p>在遊戲中，我給兩種敵人添加了不同的簡易AI。老鷹單純的添加上下移動的指令，至於青蛙則是透過動畫以及代碼的配合，做出了青蛙跳躍的感覺。兩種敵人身上都放有碰撞器，以作為實體，阻擋玩家的前進。而為了將這兩隻敵人限制在一定範圍內，我也放置了兩個空物件，作為他們移動的邊緣。<br> <img src="https://i.imgur.com/tBlNM16.png"><br>(圖四)青蛙跳躍的效果。</p><h2 id="六-UI介面"><a href="#六-UI介面" class="headerlink" title="(六)UI介面"></a>(六)UI介面</h2><p>在UI介面上，我添加了左上角的收集數量，以及暫停介面，按鈕的實作。此外，還有對話框的實現。其中的收集數量，則是透過代碼實現實時同步。至於暫停介面，亦添加了調整音效的滑桿。</p><p> <img src="https://i.imgur.com/Ar6SCZK.png"></p><p>(圖五、六、七)UI介面展示。</p><h2 id="七-音效系統"><a href="#七-音效系統" class="headerlink" title="(七)音效系統"></a>(七)音效系統</h2><p>透過掛載Audio Source在玩家物件上，並在程式碼中引用，可以視情況撥放不同的音效。例如:被擊中的音效、背景音樂等<br><img src="https://i.imgur.com/PcqzivW.png"></p><p> (圖八)Audio Source。</p><h2 id="八-燈光效果"><a href="#八-燈光效果" class="headerlink" title="(八)燈光效果"></a>(八)燈光效果</h2><p>第二個關卡中，加入光的要素，在Unity中可以使用不同的光源，來為場景提供想要的光影效果，在這個遊戲中，我簡單的添加了幾個點光源，並學習如何在遊戲中使用光源，來增添遊戲的美感。<br> <img src="https://i.imgur.com/uiSKGYO.png"></p><p>(圖九)在玩家和火焰物件上的點光源。</p><h2 id="九-場景"><a href="#九-場景" class="headerlink" title="(九)場景"></a>(九)場景</h2><p>一款遊戲中必須得有不同的場景，作為分別關卡的依據或介面等。在這款遊戲中，簡易的使用了三個場景，一個是遊戲開始介面，透過按鈕，使用已經編寫好的程式，進入第一關。而在第一關最後，則可以透過接觸到門，按下E從而進入第二關。其中包括場景的轉換等。<br><img src="https://i.imgur.com/Jx6e1OY.png"></p><p> (圖十)場景設定介面。</p>]]></content>
    
    
    <categories>
      
      <category>Game-develope</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>完整遊戲開發及自製簡易Buff系統-無限繼承-開發總結</title>
    <link href="/webHome/%5Bobject%20Object%5D/2021/10/06/game-develope/%E5%AE%8C%E6%95%B4%E9%81%8A%E6%88%B2%E9%96%8B%E7%99%BC%E5%8F%8A%E8%87%AA%E8%A3%BD%E7%B0%A1%E6%98%93Buff%E7%B3%BB%E7%B5%B1-%E7%84%A1%E9%99%90%E7%B9%BC%E6%89%BF-%E9%96%8B%E7%99%BC%E7%B8%BD%E7%B5%90/"/>
    <url>/webHome/%5Bobject%20Object%5D/2021/10/06/game-develope/%E5%AE%8C%E6%95%B4%E9%81%8A%E6%88%B2%E9%96%8B%E7%99%BC%E5%8F%8A%E8%87%AA%E8%A3%BD%E7%B0%A1%E6%98%93Buff%E7%B3%BB%E7%B5%B1-%E7%84%A1%E9%99%90%E7%B9%BC%E6%89%BF-%E9%96%8B%E7%99%BC%E7%B8%BD%E7%B5%90/</url>
    
    <content type="html"><![CDATA[<h1 id="完整遊戲開發及自製簡易Buff系統-無限繼承-開發總結"><a href="#完整遊戲開發及自製簡易Buff系統-無限繼承-開發總結" class="headerlink" title="完整遊戲開發及自製簡易Buff系統-無限繼承-開發總結"></a>完整遊戲開發及自製簡易Buff系統-無限繼承-開發總結</h1><h2 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h2><ul><li>Z-hwA</li></ul><h2 id="github連結"><a href="#github連結" class="headerlink" title="github連結"></a>github連結</h2><ul><li><a href="https://github.com/z-hwa/Unity_Game_About">點這裡</a></li></ul><h2 id="一-概要"><a href="#一-概要" class="headerlink" title="(一)概要"></a>(一)概要</h2><p>在第二款遊戲中，我的預計是要完成一款真的可以玩的遊戲，而非單單一個試驗品。因此，我決定採用無線波數這一個概念。遊戲中僅有一個場景，但在擊敗一波怪物後下一波便會出現，無限制的重複下去。而為了使這樣的遊戲充滿隨機性，以及不使人快速地感到無趣。我添加了隨機Buff系統，以及隨機怪物生成點等隨機要素。且透過這些Buff的組合，還能誕生出不同的玩法。</p><p>不過，可惜之處在於，並未曾查詢過相關於遊戲數據的書籍，以及上過相關遊戲設計課程，導致我在設計遊戲數值時，產生難度不一的情形。此外遊戲中的Buff也並未將機率有計畫性的分布，導致某些強力的Buff不斷出現，玩家強度超出預期。但這一點，也在下個遊戲中得到了改善。</p><h2 id="二-遊戲玩法"><a href="#二-遊戲玩法" class="headerlink" title="(二)遊戲玩法"></a>(二)遊戲玩法</h2><p>透過上下左右進行移動，滑鼠左鍵攻擊、右鍵進行衝鋒，S鍵存檔、P鍵暫停。每次擊敗一波後，會得到選擇Buff的機會。每十關Boss會出現一次。普通的小怪僅會透過撞擊造成傷害，但Boss有不同的攻擊模式。</p><p>Boss攻擊模式，每五秒發起一次攻擊，瞬移至玩家身邊，揮刀斬擊，命中一次後，會馬上揮出第二刀，如果第二刀揮中，會再揮出第三刀。第一刀無特殊效果，第二刀命中會回復大量生命，第三刀命中會造成超強擊退。且Boss會召喚小怪，小怪不會發起攻擊，但每隻小怪，會為Boss提供強化。</p><h2 id="三-腳色操作-攻擊、衝鋒-腳色池"><a href="#三-腳色操作-攻擊、衝鋒-腳色池" class="headerlink" title="(三)腳色操作_攻擊、衝鋒(腳色池)"></a>(三)腳色操作_攻擊、衝鋒(腳色池)</h2><p>在這一款遊戲中，為了達成擊敗敵人的效果，我為玩家添加了更實用的攻擊方式，斬擊。透過點擊鼠標左鍵，使斬擊的動畫出現，並在斬擊的動畫上添加Istrigger，使斬擊在接觸已放置碰撞體的敵人時，會出發，從而進行扣除敵人生命的程式。</p><p>相對的，一旦敵人的攻擊方式接觸到玩家，也會觸發玩家身上的碰撞器，從而啟動玩家身上扣除生命值的程式。</p><p>至於衝鋒的技能，事實上就是在短暫的時間內，提升玩家的移動速度，但為了造成玩家的回饋心理，因此設計了殘影這一要素，使玩家感受的到，「我衝鋒了」這一反饋。至於殘影，則使用對象池來實現，透過對象池得好處是能省下很多的運行浪費，且生成的物件可以重複利用。在不足以應付當前需要的數量時，則能再動態添加。</p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Awake</span>()</span>      &#123;          instance = <span class="hljs-keyword">this</span>;            <span class="hljs-comment">//初始化對象池  </span>        FillPool();      &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">FillPool</span>()</span>      &#123;          <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; shadowCount; i++)          &#123;              <span class="hljs-keyword">var</span> newShadow = Instantiate(shadowPrefab);                 newShadow.transform.SetParent(transform);                <span class="hljs-comment">//取消啟用，返回對象池                                       </span>            ReturnPool(newShadow);          &#125;      &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ReturnPool</span>(<span class="hljs-params">GameObject gameObject</span>)</span>      &#123;          gameObject.SetActive(<span class="hljs-literal">false</span>);          availableObjects.Enqueue(gameObject);      &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> GameObject <span class="hljs-title">GetFromPool</span>()</span>      &#123;          <span class="hljs-keyword">if</span>(availableObjects.Count == <span class="hljs-number">0</span>)          &#123;              FillPool();          &#125;          <span class="hljs-keyword">var</span> outShadow = availableObjects.Dequeue();            outShadow.SetActive(<span class="hljs-literal">true</span>);                  <span class="hljs-keyword">return</span> outShadow;      &#125;</code></pre></div><p>(圖十一) 腳色池程式碼(New RPG game\Assets\Scripts\ShadowPool.cs)。<br>腳色池作為殘影只是它的一個應用，用來作為射擊遊戲中的子彈，應該是較常見的用法。</p><p> <img src="https://i.imgur.com/6JC4oyx.png"><br>(圖十二)腳色衝鋒示意圖。</p><h2 id="四-敵人AI"><a href="#四-敵人AI" class="headerlink" title="(四)敵人AI"></a>(四)敵人AI</h2><p>而敵人AI也在這款遊戲中被進一步強化，雖然不具備自動尋路的能力，但也能朝著玩家的座標不斷靠近。此外，也為敵人添加了隨關卡數增加，數值隨之增加的程式。</p><p>而Boss則是這一次我嘗試著挑戰的項目，我在Boss的腳本中，設計了三段式的攻擊、瞬移的移動方式以及召喚小怪的能力。</p><p>也在Boss的頭上增加了一個倒數計時器，以方便玩家觀察Boss的攻擊模式，隨著計時器數字減少，顯示的數字顏色也會更加具有危險性。</p><p> <img src="https://i.imgur.com/4MCxOsc.png"><br>(圖十三)Boss示意圖。</p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-function">IEnumerator <span class="hljs-title">Ad</span>()</span>      &#123;          PlayerHealth player = other.gameObject.GetComponent&lt;PlayerHealth&gt;();            <span class="hljs-keyword">if</span> (attack == <span class="hljs-number">0</span>)          &#123;              <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">WaitForSeconds</span>(<span class="hljs-params"><span class="hljs-number">0.1f</span></span>)</span>;              Attack();              <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">WaitForSeconds</span>(<span class="hljs-params"><span class="hljs-number">0.4f</span></span>)</span>;              <span class="hljs-keyword">if</span> (attack == <span class="hljs-number">1</span>)              &#123;                  <span class="hljs-keyword">if</span>(hit==<span class="hljs-number">1</span>)                  &#123;                      PlayerHealth.hp -= atk;                        bossDamage = atk;                      GameObject.Find(<span class="hljs-string">&quot;Player&quot;</span>).SendMessage(<span class="hljs-string">&quot;BossAttack&quot;</span>);                                                               <span class="hljs-keyword">set</span> = <span class="hljs-number">1</span>;                      StartCoroutine(Set());                      Attack();                      <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">WaitForSeconds</span>(<span class="hljs-params"><span class="hljs-number">0.4f</span></span>)</span>;                      <span class="hljs-keyword">if</span>(hit==<span class="hljs-number">2</span>)                      &#123;                          PlayerHealth.hp -= atk + <span class="hljs-number">5</span>;                            bossDamage = atk + <span class="hljs-number">5</span>;                          GameObject.Find(<span class="hljs-string">&quot;Player&quot;</span>).SendMessage(<span class="hljs-string">&quot;BossAttack&quot;</span>);                            Boss10.hp += (atk + <span class="hljs-number">5</span>) * <span class="hljs-number">35</span> * (ClassManager.levelNum % <span class="hljs-number">10</span>) * <span class="hljs-number">6</span>;                           DamageNum damagable = Instantiate(damageCanvas, transform.position,       Quaternion.identity).GetComponent&lt;DamageNum&gt;();                          damagable.ShowUIDamage(Mathf.RoundToInt((atk + <span class="hljs-number">5</span>) * <span class="hljs-number">10000</span>), <span class="hljs-number">0</span>);                            Attack();                          <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">WaitForSeconds</span>(<span class="hljs-params"><span class="hljs-number">0.4f</span></span>)</span>;                          <span class="hljs-keyword">if</span>(hit==<span class="hljs-number">3</span>)                          &#123;                                 PlayerHealth.hp -= Boss10_Rank1.atk + <span class="hljs-number">10</span>;                                bossDamage = atk + <span class="hljs-number">10</span>;                              GameObject.Find(<span class="hljs-string">&quot;Player&quot;</span>).SendMessage(<span class="hljs-string">&quot;BossAttack&quot;</span>);                                                            hitAfter = <span class="hljs-number">1</span>;                          &#125;                      &#125;                  &#125;              &#125;          &#125;</code></pre></div><p>(圖十四)Boss攻擊模式程式碼<br>(New RPG game\Assets\Scripts\Boss10_Rank1.cs)。</p><h2 id="五-UI介面"><a href="#五-UI介面" class="headerlink" title="(五)UI介面"></a>(五)UI介面</h2><p>遊戲介面同樣有暫停，除此之外，更添加了buff的顯示區塊，關卡的提示等。而玩家身上的血條UI，則是透過三張不同顏色的圖片，設置成填充模式以達成。至於扣血效果的UI則製成了預製體，需要時調用。最後則是分數計算的顯示，跟上一款遊戲的收集櫻桃是類似的。</p><p> <img src="https://i.imgur.com/srS8pZ6.png"><br><img src="https://i.imgur.com/NdThXkD.png"><br><img src="https://i.imgur.com/01PofLb.png"></p><p>(圖十五、十六、十七)UI介面。<br>此外，也於遊戲中製作了預製體的扣血效果，並於怪物或玩家受到傷害時，生成於玩家或是怪物的身旁。而Boss身上則有額外的綠色效果，作為回血的數值。<br> <img src="https://i.imgur.com/FMtNUT8.png"><br>(圖十八)回復以及扣血效果。</p><h2 id="六-程式碼-無限波數、Buff系統、存檔系統"><a href="#六-程式碼-無限波數、Buff系統、存檔系統" class="headerlink" title="(六)程式碼_無限波數、Buff系統、存檔系統"></a>(六)程式碼_無限波數、Buff系統、存檔系統</h2><p>為了提升遊戲的可玩性，以及使遊戲的紀錄可被儲存，我上網查詢有關於這方面的教學影片以及文章。三者之中，最容易達成的是無限波數的部分，透過程式碼中的變數調控，以檢測場上敵人的數目來決定是否進入下一波。</p><p>一旦進入下一波，再透過隨機生成的方式，隨機生成敵人到場上，每十關出現一次Boss。</p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>()</span>      &#123;                <span class="hljs-keyword">if</span> (enemy == <span class="hljs-number">0</span>) <span class="hljs-comment">//召喚怪物  </span>        &#123;              enemyCount = (ClassManager.levelNum<span class="hljs-number">-1</span>) * <span class="hljs-number">1</span> % <span class="hljs-number">5</span>;              <span class="hljs-keyword">if</span>(enemyCount==<span class="hljs-number">0</span>)              &#123;                  Appear();              &#125;                <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; enemyCount; i++)                  Appear();              &#125;              enemy = <span class="hljs-number">1</span>;          &#125;                    Record();      &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Appear</span>() <span class="hljs-comment">//隨機出現位置  </span></span>    &#123;          <span class="hljs-built_in">float</span> x = Random.Range(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>);          <span class="hljs-built_in">float</span> y = Random.Range(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>);            <span class="hljs-keyword">if</span> ((ClassManager.levelNum % <span class="hljs-number">10</span>) != <span class="hljs-number">1</span>)          &#123;              point.transform.position = <span class="hljs-keyword">new</span> Vector2(point.transform.position.x + x, point.transform.position.y + y);              Instantiate(enemyBat, point.transform.position, enemyBat.transform.rotation);              point.transform.position = <span class="hljs-keyword">new</span> Vector2(point.transform.position.x - x, point.transform.position.y - y);              Instantiate(enemyBeast, point.transform.position, enemyBeast.transform.rotation);                nowEnemyCount += <span class="hljs-number">2</span>;          &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((ClassManager.levelNum%<span class="hljs-number">10</span>)==<span class="hljs-number">1</span>)          &#123;              point.transform.position = <span class="hljs-keyword">new</span> Vector2(point.transform.position.x - x, point.transform.position.y - y);              Instantiate(boss10, point.transform.position, boss10.transform.rotation);                            nowEnemyCount += <span class="hljs-number">1</span>;          &#125;      &#125;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Record</span>() <span class="hljs-comment">//重新激活  </span></span>    &#123;          <span class="hljs-keyword">if</span> (nowEnemyCount == <span class="hljs-number">0</span> &amp;&amp; run == <span class="hljs-number">0</span>)          &#123;              <span class="hljs-keyword">if</span>(score==<span class="hljs-number">1</span>)              &#123;                  ScoreInformation.scorePower += timeScore * <span class="hljs-number">10</span> * ((ClassManager.levelNum / <span class="hljs-number">2</span>) + <span class="hljs-number">1</span>);                  timeScore = <span class="hljs-number">50</span>;              &#125;                GameObject.Find(<span class="hljs-string">&quot;GameStartCanvas&quot;</span>).SendMessage(<span class="hljs-string">&quot;Run&quot;</span>);              run = <span class="hljs-number">1</span>;              score = <span class="hljs-number">1</span>;          &#125;      &#125;</code></pre></div><p>(圖十九)敵人生成及波數程式碼<br>(New RPG game\Assets\Scripts\EnemyAppearManager.cs)。</p><p>至於存檔機制則是因為網路上有種類繁多的教程，因此在實作過程中，沒有遇到特別多的困難。最後我選擇PlayerPrefs作為存檔的方式，但在下一款遊戲中，我將PlayerPrefs、序列化:二進制、序列化:JSON、序列化:XML都學習過了，後邊會提到。</p><div class="code-wrapper"><pre><code class="hljs csharp">maxHp = PlayerHealth.maxNowHp;  PlayerPrefs.SetFloat(<span class="hljs-string">&quot;maxHp&quot;</span>, maxHp);    maxHp = PlayerPrefs.GetFloat(<span class="hljs-string">&quot;maxHp&quot;</span>);</code></pre></div><p>(圖二十)PlayerPrefs存檔方式(New RPG game\Assets\Scripts\Load01.cs)。</p><p>最後的Buff系統則是困擾了我數天，其原因在於網路上並沒有相關的教程。因此，我開始構思一個能隨機產生Buff並給予玩家選擇的機制。</p><p>在我看來，Buff系統的核心有三個，資料庫、管道、生成。</p><p>資料庫中儲存有關於這個Buff的資料，玩家在選擇時，資料便會出現，提供玩家有關於這個Buff的能力。管道則是將程式裡的Buff系統實際顯示在遊戲屏幕上的方式，這裡我使用了UI以及隨機取數來完成，隨機生成三個可供選擇的Buff。最後的生成，則是使效果生成，只需要在程式碼中修改相關的變數即可。</p><p>Buff系統本體:<br>(New RPG game\Assets\Scripts\Buff.cs)。<br>Buff系統資料庫:<br>(New RPG game\Assets\Scripts\BuffData.cs)。<br>在實作Buff機制時，遇到了十分大的挫折，光是Buff系統的構思，便出錯了數次，導致出現奇怪的結果。但更多的是沒有任何反應，時間也一分一秒的在減少，那時候每天都是早上8點起床，坐在電腦前實作到晚上12點。</p><p>雖然實際上的程式碼不多，似乎不需要那麼久的時間，但浪費最多時間的是重覆的試驗。</p><p>除此之外，也不斷查詢是否有相關的資料能幫助我完成這項任務，儘管最後是靠著靈光一閃解決了這個問題，但如果沒有那些天累積的知識，這個點子也不會出現。</p><p>也是在這次的Buff系統過後，我開始真正掌握到編寫遊戲程式的感覺，以及真正開發著一款遊戲。</p><h2 id="七-子彈功能-追蹤彈"><a href="#七-子彈功能-追蹤彈" class="headerlink" title="(七)子彈功能_追蹤彈"></a>(七)子彈功能_追蹤彈</h2><p>這款遊戲最後要提到的就是追蹤彈的功能。在實作遊戲時，我常會到各個影片網站尋找對開發有幫助的影片，也是因此，意外的發現了有關於子彈追蹤的影片。實際上，如果要做出簡單的追蹤子彈效果，使用Trail就能完成。</p><p>但僅僅是子彈朝著敵人直線射擊過去，就少了一點味道，原先是不打算製作的。只是，那部影片與子彈軌跡有關，因此，在看到那個影片後，我才決定製作這一功能。</p><p>不過，這項功能的開發只算是作為研究的目的，並沒有將其實裝在遊戲中的想法，因此，實際的遊戲中需要啟動隱藏的測試按鈕，才能使用。</p><p>之所以不實裝的原因之一，是因為Buff系統的協調出了點問題，調適需要一段時間。其次，則是我當時對於這個功能的想法並不多，所以沒有下手大改這款遊戲，畢竟，本來這款遊戲的目的是設計為一款近戰遊戲。</p><p>以下是開啟射擊模式的方法:進入暫停介面，需要將鼠標移到黑塊的相應位置處，黑塊才會顯示。<br><img src="https://i.imgur.com/wZ2qkEx.png"></p><p>(圖二十一)射擊模式開啟方法。</p><p><img src="https://i.imgur.com/BEag6UW.png"></p><p>(圖二十二)射擊模式示意圖。</p><p>在這個系統中，可以透過調整角度的係數，從而實現不同的子彈軌跡，以下是另一種不同的軌跡示範。<br><img src="https://i.imgur.com/8r4Bcpz.png"></p><p>(圖二十三)類似閃電的子彈軌跡示意圖。</p><div class="code-wrapper"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Chase</span>()</span>      &#123;          Vector3 direction = target.transform.position - <span class="hljs-keyword">this</span>.transform.position; <span class="hljs-comment">//朝向目標  </span>        <span class="hljs-built_in">float</span> ang = <span class="hljs-number">360</span> - Mathf.Atan2(direction.x, direction.y) * Mathf.Rad2Deg; <span class="hljs-comment">//方向向量轉角度  </span>        transform.eulerAngles = <span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, ang); <span class="hljs-comment">//角度設為對應角度  </span>          <span class="hljs-keyword">this</span>.transform.rotation = <span class="hljs-keyword">this</span>.transform.rotation * Quaternion.Euler(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, rotationAngle);          transform.Translate(Vector3.up * bulletSpeed * Time.deltaTime);      &#125;</code></pre></div><p>(圖二十四)實現子彈軌跡的程式碼<br>(New RPG game\Assets\Scripts\NormalBullet.cs)。</p><p>透過在這個程式碼中調整係數，便能做到不同的子彈軌跡效果。雖然這個功能在這款遊戲裡並沒有正式加入，但也多虧這個功能的啟發，讓我有了製作下一款遊戲的念頭，製作一款射擊類遊戲。</p><h2 id="八-參考資料"><a href="#八-參考資料" class="headerlink" title="(八)參考資料"></a>(八)參考資料</h2><ul><li><a href="https://www.bilibili.com/video/BV1qt4y1U7aS">無限繼承_基礎教學影片1</a></li><li><a href="https://www.bilibili.com/video/BV1VT4y1G7Vq">無限繼承_基礎教學影片2</a></li><li><a href="https://youtu.be/hX9qFnjg7zw">無限繼承_衝鋒效果教學影片1</a></li><li><a href="https://youtu.be/osdxOLz6_wc">無限繼承_衝鋒效果教學影片2</a></li><li><a href="https://youtu.be/ZsvCNpvwPSc">無限繼承_衝鋒效果教學影片3</a></li><li><a href="https://www.bilibili.com/video/BV1WJ411778C">無限繼承_腳色血條UI教學影片</a></li><li><a href="https://www.bilibili.com/video/BV1u4411T7jZ">無限繼承_子彈軌跡追蹤教學影片</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Game-develope</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>AIS3_projext-Stuxnet</title>
    <link href="/webHome/%5Bobject%20Object%5D/2021/10/04/security/AIS3-projext-Stuxnet/"/>
    <url>/webHome/%5Bobject%20Object%5D/2021/10/04/security/AIS3-projext-Stuxnet/</url>
    
    <content type="html"><![CDATA[<h1 id="AIS3專題-Stuxnet"><a href="#AIS3專題-Stuxnet" class="headerlink" title="AIS3專題 - Stuxnet"></a>AIS3專題 - Stuxnet</h1><h1 id="Teammate-Author"><a href="#Teammate-Author" class="headerlink" title="Teammate &amp; Author"></a>Teammate &amp; Author</h1><ul><li>Z-hwA</li><li><a href="https://github.com/gunjyo0817">Gunjyo</a></li><li>Yinxiehuang</li></ul><h1 id="link"><a href="#link" class="headerlink" title="link"></a>link</h1><ul><li><a href="https://attack.mitre.org/">Mitre ATT&amp;CK</a></li><li><a href="https://drive.google.com/file/d/1VExENll3iGpW47T7ZrRZtR9xfp9Wrlpz/view?usp=sharing">報告PDF</a><!--# 實作--></li></ul><h1 id="震網stuxnet病毒"><a href="#震網stuxnet病毒" class="headerlink" title="震網stuxnet病毒"></a>震網stuxnet病毒</h1><p><a href="https://github.com/SilverPoision/stuxnet-source-code">惡意軟體下載</a></p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>第一個以關鍵工業基礎設施為目標的蠕蟲，還有一種叫做Dropper的特洛伊木馬被安裝在裡面，目的是要將惡意軟體放在受害的電腦上。<br>有七個漏洞分別針對的兩種不同作業係統(WINDOWS,SIMATIC WinCC&#x2F;STEP 7):</p><ol><li>CVE-2008-4250（MS08-067）</li><li>CVE-2010-2568（MS10-046）(0Day)</li><li>CVE-2010-2729（MS10-061）(0Day)</li><li>CVE-2010-2743（MS10-073）(0Day)</li><li>CVE-2010-3338（MS10-092）(0Day)</li><li>CVE-2010-2772（0Day)</li></ol><p>攻擊伊朗核電廠、煉油廠、電廠、水庫…etc。<br>(Flame作為Stuxnet的前身，Flame極為重視隱藏，sent data in smaller chunk)</p><div class="code-wrapper"><pre><code class="hljs subunit">使用以下CVE///MS10<span class="hljs-string">-046</span> Windows 快捷方式漏洞(CVE<span class="hljs-string">-2010</span><span class="hljs-string">-2568</span>)，允許在用戶不知情下，下載random dynamic library，是windows處理標籤的漏洞(LNK)，用於傳播///MS08<span class="hljs-string">-067</span> RPC漏洞 (CVE<span class="hljs-string">-2008</span><span class="hljs-string">-4250</span>)，使用特製RPC，以系統級權限遠程執行代碼，執行NetPathCanonicalize函數(存在邏輯錯誤)，導致緩衝區溢出(RCE)，進而掌握windows，用於網路傳播///MS10<span class="hljs-string">-061</span> 打印機後台處理程序漏洞(CVE<span class="hljs-string">-2010</span><span class="hljs-string">-2729</span>)，因windows的打印機後台程序(用戶權限設置不合理)，可透過發送打印請求，使文件傳進接口主機的%system32%目錄中，以系統權限執行代碼。///(CVE<span class="hljs-string">-2010</span><span class="hljs-string">-2772</span>) winCC默認密碼繞過漏洞，用於刪除修改痕跡</code></pre></div><p>目標：伊朗使用西門子控制系統的核電基礎設施<br>被入侵後，表面上會顯示設備一切正常，而實際上會造成離心機因為高速運轉失效<br><a href="https://www.antiy.com/response/stuxnet/Report_on_the_Worm_Stuxnet_Attack.html">綜合分析報告</a></p><h2 id="感染流程圖"><a href="#感染流程圖" class="headerlink" title="感染流程圖"></a>感染流程圖</h2><p><img src="https://i.imgur.com/uQRJTM2.jpg"><br><img src="https://i.imgur.com/M2zyzEW.png"><br><img src="https://i.imgur.com/zGpb0YT.jpg"><br>被植入前正常的 PLC 控制流程<br><img src="https://i.imgur.com/kowDgTi.png"><br>被感染的 PLC 控制流程<br><img src="https://i.imgur.com/WVJHeVq.png"><br>生命週期<br><img src="https://www.codeproject.com/KB/web-security/StuxnetMalware/01.jpg"><br>WTR4132.TMP可用來解釋這個循環中的每一步，加載到Explorer.exe 中的動態連結程式庫(將再啟動時描述他是如何加載)，是現實中共享函示庫的一種方式，副檔名為.dll or .OCX or .DRV等等。</p><h2 id="分析WTR4131-TMP"><a href="#分析WTR4131-TMP" class="headerlink" title="分析WTR4131.TMP"></a>分析WTR4131.TMP</h2><p>WTR4132.TMP它通過在其中搜索名為“.stub”來開始執行。<br>這個”.stub”包含主要的stuxnet DLL 文件，也就是說包含了所有機制、檔案、功能、rootkit等等。<br><img src="https://i.imgur.com/HoegmTr.png"><br>找到.stub的MZ文件:(引用論文)<br><img src="https://i.imgur.com/l7PiCsl.png"><br>這部分會對要加在的DLL文件分配內存緩衝，還會Paches 6 個ntdll.dll API：</p><ol><li>ZwMapViewOfSection</li><li>ZwCreateSection</li><li>ZwOpenFile</li><li>ZwClose</li><li>ZwQueryAttributesFile </li><li>ZwQuerySection</li></ol><h2 id="提升權限並注入"><a href="#提升權限並注入" class="headerlink" title="提升權限並注入"></a>提升權限並注入</h2><p>當主DLL被執行時，會檢查管理員的權限。如果不是在管理員權限運行，會執行以下兩個0Day漏洞:</p><ol><li>任務計劃程序程序漏洞（MS10-092）</li><li>內核模式驅動程序漏洞(MS-10-073)</li></ol><h2 id="MS10-061-打印機後台處理程序漏洞-CVE-2010-2729"><a href="#MS10-061-打印機後台處理程序漏洞-CVE-2010-2729" class="headerlink" title="MS10-061 打印機後台處理程序漏洞(CVE-2010-2729)"></a>MS10-061 打印機後台處理程序漏洞(CVE-2010-2729)</h2><ul><li><p>復現<br><a href="https://juejin.cn/post/6844903782644449293#heading-15">https://juejin.cn/post/6844903782644449293#heading-15</a></p></li><li><p>SOP</p><ul><li>環境架設<ul><li>攻擊機：Kali Linux虛擬機</li><li>靶機：Windows xp sp3虛擬機</li></ul></li><li>靶機環境配置<ul><li>IP 192.168.17.128<br>  <img src="https://i.imgur.com/JtDX85u.png"></li><li>Printer</li></ul></li><li>Attack<br>  <img src="https://i.imgur.com/ADaGabZ.png"></li></ul></li></ul><h3 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h3><p><a href="https://blog.csdn.net/Ping_Pig/article/details/109218430">https://blog.csdn.net/Ping_Pig/article/details/109218430</a><br><a href="https://www.icode9.com/content-4-734382.html">https://www.icode9.com/content-4-734382.html</a></p><h2 id="MS08-067-RPC漏洞-CVE-2008-4250"><a href="#MS08-067-RPC漏洞-CVE-2008-4250" class="headerlink" title="MS08-067 RPC漏洞 (CVE-2008-4250)"></a>MS08-067 RPC漏洞 (CVE-2008-4250)</h2><ul><li>復現<br><a href="https://www.freesion.com/article/3818878411/">實作流程</a></li></ul><h2 id="MS10-046-Windows-快捷方式漏洞-CVE-2010-2568"><a href="#MS10-046-Windows-快捷方式漏洞-CVE-2010-2568" class="headerlink" title="MS10-046 Windows 快捷方式漏洞(CVE-2010-2568)"></a>MS10-046 Windows 快捷方式漏洞(CVE-2010-2568)</h2><p>好像挖到甚麼好東西了0.0<br><a href="http://ith4cker.com/content/uploadfile/201804/44eb1522835054.pdf">Windows Lnk Vul Analysis:From CVE-2010-2568(Stuxnet 1.0) to<br>CVE-2017-8464(Stuxnet 3.0)</a></p><ul><li>復現<br><a href="https://www.freesion.com/article/2561527899/">實作流程</a><br><a href="https://www.huaweicloud.com/articles/12550200.html">實驗流程中缺少的ettercap DNS欺騙教學</a><br><a href="https://apk.tw/thread-875046-1-1.html">winXP iso映像檔</a><br><a href="https://www.cnblogs.com/pchmonster/p/12041490.html">winXP iso安裝於VMware教學</a></li></ul><p>補充:<br><a href="https://www.ynpxrz.com/n1506974c2029.aspx">DNS網欺原理</a></p><h2 id="refs-1"><a href="#refs-1" class="headerlink" title="refs"></a>refs</h2><p><a href="https://github.com/loneicewolf/Stuxnet-Source">Stuxnet-Source</a><br><a href="https://github.com/micrictor/stuxnet">https://github.com/micrictor/stuxnet</a><br><a href="https://www.mcafee.com/blogs/other-blogs/mcafee-labs/stuxnet-update/">漏洞資料來源</a><br><a href="https://blog.trendmicro.com.tw/?tag=stuxnet">資安趨勢blog</a><br><a href="https://zhuanlan.zhihu.com/p/378291643">网络战武器——震网(Stuxnet)病毒</a><br><a href="https://paper.seebug.org/1047/">震网事件的九年再复盘与思考</a><br><a href="https://ithelp.ithome.com.tw/articles/10186904">[Day07] 病毒介紹 - 病毒界也有電影明星</a><br><a href="https://www.codeproject.com/articles/246545/stuxnet-malware-analysis-paper">分析論文</a></p><h1 id="ghidra反編譯"><a href="#ghidra反編譯" class="headerlink" title="ghidra反編譯"></a>ghidra反編譯</h1><p><a href="https://bingfeng.tw/thread-1488913-1-1.html">基礎教學</a></p>]]></content>
    
    
    <categories>
      
      <category>Security</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Unity-ML-agents material</title>
    <link href="/webHome/%5Bobject%20Object%5D/2021/10/04/ai/Unity-ML-agents%20material/"/>
    <url>/webHome/%5Bobject%20Object%5D/2021/10/04/ai/Unity-ML-agents%20material/</url>
    
    <content type="html"><![CDATA[<h1 id="Unity-ml-agents補充資料"><a href="#Unity-ml-agents補充資料" class="headerlink" title="Unity_ml-agents補充資料"></a>Unity_ml-agents補充資料</h1><h2 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h2><ul><li>Z-hwA</li></ul><h2 id="影片支援-最好能看一看"><a href="#影片支援-最好能看一看" class="headerlink" title="影片支援(最好能看一看):"></a>影片支援(最好能看一看):</h2><p>unity從零開始打基礎(學完你就能在Untiy隨心所欲了):<br><a href="https://youtube.com/playlist?list=PL_Pb2I110MfGAsoqtDs8-6kEU55wU8CnE">https://youtube.com/playlist?list=PL_Pb2I110MfGAsoqtDs8-6kEU55wU8CnE</a></p><p>基本架構(最重要，純英文):</p><p>How to use Machine Learning AI in Unity! (ML-Agents)<br> <a href="https://youtu.be/zPFU30tbyKs">https://youtu.be/zPFU30tbyKs</a><br>Teach your AI! Imitation Learning with Unity ML-Agents!<br><a href="https://youtu.be/supqT7kqpEI">https://youtu.be/supqT7kqpEI</a></p><p>額外補充AI知識(中文，AI訓練基本原理):</p><p>機器學習簡介:<br><a href="https://learndigital.withgoogle.com/digitalgarage-tw/course/machine-learning-basics/module/141">https://learndigital.withgoogle.com/digitalgarage-tw/course/machine-learning-basics/module/141</a><br>鴻海基金會_認識AI:<br><a href="https://youtu.be/dTwsC6x79iY">https://youtu.be/dTwsC6x79iY</a><br>ASUS_AI邊緣運算:<br><a href="https://youtu.be/SisTX-YG1ic">https://youtu.be/SisTX-YG1ic</a><br>鴻海_基本神經網路架構:<br><a href="https://youtu.be/3BmuZHmA9lE">https://youtu.be/3BmuZHmA9lE</a><br>人工智慧與深度學習:<br><a href="https://youtu.be/QRUxDNToALs">https://youtu.be/QRUxDNToALs</a></p><h2 id="文件支援-想要更進一步，那就來挑戰吧"><a href="#文件支援-想要更進一步，那就來挑戰吧" class="headerlink" title="文件支援(想要更進一步，那就來挑戰吧):"></a>文件支援(想要更進一步，那就來挑戰吧):</h2><p>Unity關於ml_agents的文檔(核心中的核心，最硬的，全英文+專有名詞):<br><a href="https://github.com/Unity-Technologies/ml-agents/tree/main/docs">https://github.com/Unity-Technologies/ml-agents/tree/main/docs</a><br>Unity_Tensorboard用來記錄我們訓練數據的功能描述(全英文):<br><a href="https://github.com/Unity-Technologies/ml-agents/blob/main/docs/Using-Tensorboard.md">https://github.com/Unity-Technologies/ml-agents/blob/main/docs/Using-Tensorboard.md</a><br>熙陽官方ml-agents案例示範(全中文，部分官方文檔解釋，新手入門的好選擇):<br><a href="https://www.cnblogs.com/gentlesunshine/p/12452360.html">https://www.cnblogs.com/gentlesunshine/p/12452360.html</a><br><a href="https://www.cnblogs.com/gentlesunshine/p/12507677.html">https://www.cnblogs.com/gentlesunshine/p/12507677.html</a><br><a href="https://www.cnblogs.com/gentlesunshine/p/12590516.html">https://www.cnblogs.com/gentlesunshine/p/12590516.html</a><br><a href="https://www.cnblogs.com/gentlesunshine/p/12602404.html">https://www.cnblogs.com/gentlesunshine/p/12602404.html</a><br><a href="https://www.cnblogs.com/gentlesunshine/p/12639136.html">https://www.cnblogs.com/gentlesunshine/p/12639136.html</a><br><a href="https://www.cnblogs.com/gentlesunshine/p/12681019.html">https://www.cnblogs.com/gentlesunshine/p/12681019.html</a><br><a href="https://www.cnblogs.com/gentlesunshine/p/12723175.html">https://www.cnblogs.com/gentlesunshine/p/12723175.html</a><br><a href="https://www.cnblogs.com/gentlesunshine/p/12790103.html">https://www.cnblogs.com/gentlesunshine/p/12790103.html</a><br><a href="https://www.cnblogs.com/gentlesunshine/p/12838969.html">https://www.cnblogs.com/gentlesunshine/p/12838969.html</a><br><a href="https://www.cnblogs.com/gentlesunshine/p/13026842.html">https://www.cnblogs.com/gentlesunshine/p/13026842.html</a></p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料:"></a>參考資料:</h2><p>(1) 賈森浩(2017)‧游戏人工智能中 A*算法的应用研究‧中國杭州:杭州電子科技大學。<br>(2) Jockey Ng (2019 年 2 月 20 日 ) ． 強 化 學 習 Reinforcement Learning ．取自 :<br><a href="https://medium.com/@jockeyng/%E5%BC%B7%E5%8C%96%E5%AD%B8%E7%BF%92-">https://medium.com/@jockeyng/%E5%BC%B7%E5%8C%96%E5%AD%B8%E7%BF%92-</a><br>reinforcement-learning-487aef228c04。<br>(3) Arthur Juliani (201, March 15). ML-Agents Toolkit v0.3 Beta released: Imitation Learning,<br>feedback-driven features, and more. Unity Blog, from <a href="https://blogs.unity3d.com/2018/03/15/ml%02agents-v0-3-beta-released-imitation-learning-feedback-driven-features-and%02more/?_ga=2.201113965.218827823.1616313306-576441710.1608305998">https://blogs.unity3d.com/2018/03/15/mlagents-v0-3-beta-released-imitation-learning-feedback-driven-features-andmore/?_ga=2.201113965.218827823.1616313306-576441710.1608305998</a><br>(4) Arthur Juliani (2017, December 8 ). Introducing ML-Agents Toolkit v0.2: Curriculum Learning,<br>new environments, and more. Unity Blog, from <a href="https://blogs.unity3d.com/2017/12/08/">https://blogs.unity3d.com/2017/12/08/</a><br>introducing-ml-agents-v0-2-curriculum-learning-new-environments-andmore&#x2F;?_ga&#x3D;2.201113965.218827823.1616313306-576441710.1608305998<br>(5) Alessia Nigretti (2017, December 11). Using Machine Learning Agents Toolkit in a real game:<br>a beginner’s guide. Unity Blog, from <a href="https://blogs.unity3d.com/2017/12/11/using-machine%02learning-agents-in-a-real-game-a-beginners-guide">https://blogs.unity3d.com/2017/12/11/using-machinelearning-agents-in-a-real-game-a-beginners-guide</a></p>]]></content>
    
    
    <categories>
      
      <category>AI-about</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Unity_ML-agents basic</title>
    <link href="/webHome/%5Bobject%20Object%5D/2021/10/03/ai/Unity_ML-agents%20basic/"/>
    <url>/webHome/%5Bobject%20Object%5D/2021/10/03/ai/Unity_ML-agents%20basic/</url>
    
    <content type="html"><![CDATA[<p>#科展環境準備及基礎</p><h2 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h2><ul><li>Z-hwA</li></ul><h2 id="ch1環境設置"><a href="#ch1環境設置" class="headerlink" title="ch1環境設置"></a>ch1環境設置</h2><p>在使用Unity之前，我們必須先到官網下載Unity的hub，透過Unity hub我們能夠簡單的安裝各種版本的Unity，以及使用。</p><h3 id="A部分-Untiy安裝"><a href="#A部分-Untiy安裝" class="headerlink" title="A部分 Untiy安裝:"></a>A部分 Untiy安裝:</h3><h4 id="第一步-安裝Unity-Hub"><a href="#第一步-安裝Unity-Hub" class="headerlink" title="第一步 安裝Unity Hub:"></a>第一步 安裝Unity Hub:</h4><p>前往Unity download頁面。<br>連結:<a href="https://unity3d.com/get-unity/download">https://unity3d.com/get-unity/download</a></p><p><img src="https://i.imgur.com/UDXyvL9.png"><br>點擊Download Unity Hub，下載完後直接安裝即可。接下來，我們暫時不需要去使用，因此先不用開啟。</p><h4 id="第二步-註冊一個Unity帳號"><a href="#第二步-註冊一個Unity帳號" class="headerlink" title="第二步 註冊一個Unity帳號:"></a>第二步 註冊一個Unity帳號:</h4><p>前往Unity ID介面。</p><p>連結:<a href="https://id.unity.com/en/conversations/2f5fc0c0-6945-4320-922e-f2bac8fefc2801cf?view=register">https://id.unity.com/en/conversations/2f5fc0c0-6945-4320-922e-f2bac8fefc2801cf?view=register</a><br><img src="https://i.imgur.com/2Zxy8hc.png"><br>在這個頁面註冊一個Unity帳號，這個Unity帳號，能讓我們在Unity Hub中激活我們的授權，從而能夠使用Unity。</p><h4 id="第三步-授權"><a href="#第三步-授權" class="headerlink" title="第三步 授權:"></a>第三步 授權:</h4><p>開啟Unity Hub，點擊右上方的紅色框登入後。在下方會出現訊息，此訊息應該為「Unity尚未授權」等提示。這裡我因為已經授權過了，所以提示授權即將到期。(授權期很短，因此打開經常會收到這樣的訊息，提示授權即將到期。不須去理會，只需要等授權時間到再次授權即可)。</p><p>點擊管理授權，進入授權介面，之後如果需要重新授權也是參照以下步驟。</p><p><img src="https://i.imgur.com/4h7gWPt.png"></p><p><img src="https://i.imgur.com/4AZs2Y2.png"><br>登入後即可選擇啟用新的授權，如果沒有登入的話，就會是灰色的。按下它!!!</p><p><img src="https://i.imgur.com/23laxoi.png"><br>接下來，參照我的設定激活授權。按下完成。</p><p>完成授權。</p><h4 id="第四步-安裝對應版本的Untiy"><a href="#第四步-安裝對應版本的Untiy" class="headerlink" title="第四步 安裝對應版本的Untiy:"></a>第四步 安裝對應版本的Untiy:</h4><p>接下來，退出喜好設定。</p><p>打開Unity Hub左邊的清單上選擇安裝，進入安裝介面，點選新增。並選擇你需要的Unity版本，本教程的建議版本為2020.3.0f1(LTS)。</p><p><img src="https://i.imgur.com/LlafkWf.png"><br>建議在選擇版本時，選擇帶有(LTS)字樣的版本，這意味著，Unity官方將對這個版本做出長期的維護，而不會閒置它。</p><p><img src="https://i.imgur.com/qFyA6t0.png"><br><img src="https://i.imgur.com/enaLptF.png"><br>請注意，如果你的電腦中沒有裝Visual Studio那麼在第一款Unity安裝時，會多出一個下載Visual Studio的選項，請勾上它。下一節，我們將說到如何安裝Visual Studio</p><p>選擇好版本後，按下一步。對我們的Untiy需要用的的環境做配置，這裡我的配置能夠開發(IOS、Android、Windows)的應用。在本次ML-agents的教程中，只需要用到Windows即可。</p><p>選擇完成後，便會自動開始下載以及安裝，如果有勾取下載Android Studio的同學們，請到B部分，學習如何配置Android Studio。</p><h3 id="B部分-Visual-Studio安裝"><a href="#B部分-Visual-Studio安裝" class="headerlink" title="B部分 Visual Studio安裝"></a>B部分 Visual Studio安裝</h3><p>等到你的Untiy自動安裝到最後的時候，會跳出visual studio的安裝引導，就跟著他做，並選擇下方的配置即可。</p><p>如果沒有跳出來，就在開始搜尋visual studio installer點開他，根據他的要求操作。</p><p>應該是重開機之後，就會在跳出來，這個時候選擇修改，照著下面的步驟做下去。</p><h4 id="第一步-開發環境"><a href="#第一步-開發環境" class="headerlink" title="第一步 開發環境:"></a>第一步 開發環境:</h4><p>在這裡我們選擇Unity即可。如果有其他的程式語言開發需求，再安裝其他的環境即可。</p><p><img src="https://i.imgur.com/ClD4kc1.png"><br>選好之後，點擊右下角的按鍵即可，因為我的已經安裝好了，所以字樣是修改，你們的應該會不一樣。</p><p>接下來，等待Unity以及Visual Studio完成安裝。</p><h3 id="C部分-確認以上兩項的安裝都已確實完成，以及腳本代碼補全功能存在"><a href="#C部分-確認以上兩項的安裝都已確實完成，以及腳本代碼補全功能存在" class="headerlink" title="C部分 確認以上兩項的安裝都已確實完成，以及腳本代碼補全功能存在"></a>C部分 確認以上兩項的安裝都已確實完成，以及腳本代碼補全功能存在</h3><h4 id="第一步-檢測"><a href="#第一步-檢測" class="headerlink" title="第一步 檢測:"></a>第一步 檢測:</h4><p>最後的設定，請讓我們打開你下載的Unity，選擇新專案，選擇3D專案，命名，建立。</p><p><img src="https://i.imgur.com/TiX33wF.png"><br><img src="https://i.imgur.com/OCPDdrw.png"><br>接下來，會自動進入Unity的基礎介面，在後面的章節會介紹如何使用，</p><p><img src="https://i.imgur.com/wGwhnnR.png"><br>然後，點擊上方的Edit，Preferences，進入Preferences介面。</p><p><img src="https://i.imgur.com/7VKx3Xu.png"><br>然後，點擊Extemal Tools，將External Scripts Edito中的預設選項，修改為你的Visual Studio版本，我這裡選擇2019。完成後即可關閉Preferences介面。</p><p><img src="https://i.imgur.com/8WC8hZG.png"><br>現在請讓我們建立一個腳本在Assets中。</p><p>在Assets區域中按下滑鼠右鍵，Create，C#Script。雙擊它，會自動打開Visual Studio並可以看見以下預設腳本。</p><p><img src="https://i.imgur.com/GM8mjr6.png"><br>請跟著我打上public ga的字，如果在你輸入的過程中，有跑出我框住的字樣(GameObject)，那麼就完成設定了。</p><p>如果有其他問題，可以向我提問，或是到以下參考影片中，重新設定一次。<br>參考影片:<a href="https://www.youtube.com/watch?v=Wns-DZbMyIw">https://www.youtube.com/watch?v=Wns-DZbMyIw</a></p><p>恭喜你，完成Unity基礎環境設定，完成了以上步驟的你，現在已經踏上做為一名開發者的第一步階梯了。</p><h3 id="D部分-ML-agents環境設置-請在本次範例的專案中進行，優先完成ch2的A部分，開啟一個專案，再回來做這裡"><a href="#D部分-ML-agents環境設置-請在本次範例的專案中進行，優先完成ch2的A部分，開啟一個專案，再回來做這裡" class="headerlink" title="D部分 ML-agents環境設置(請在本次範例的專案中進行，優先完成ch2的A部分，開啟一個專案，再回來做這裡)"></a>D部分 ML-agents環境設置(請在本次範例的專案中進行，優先完成ch2的A部分，開啟一個專案，再回來做這裡)</h3><h4 id="第零步-簡述"><a href="#第零步-簡述" class="headerlink" title="第零步 簡述:"></a>第零步 簡述:</h4><p>該部分內容參考了Unity官方英文文檔以及Code Monkey大神在Youtube的”How to use Machine Learning AI in Unity! (ML-Agents)”影片，因此，如果你的英文還不錯，那麼我建議你自己去看英文文檔以及原影片，以防有翻譯上的問題。</p><h4 id="第一步-打開終端機"><a href="#第一步-打開終端機" class="headerlink" title="第一步 打開終端機:"></a>第一步 打開終端機:</h4><p><img src="https://i.imgur.com/d2IP1xg.png"><br>在開始頁面中，搜尋CMD，並選擇命令提示字元(CMD)。</p><p>接下來的指令輸入，部分暫時沒有圖片支援，建議搭配影片食用01:22~10:10。</p><h4 id="第二步-進入我們的專案中"><a href="#第二步-進入我們的專案中" class="headerlink" title="第二步 進入我們的專案中:"></a>第二步 進入我們的專案中:</h4><p>讓終端機，移動到想要用來訓練AI的Unity專案。</p><p><img src="https://i.imgur.com/nJdUKdg.png"><br>在”&gt;”之前的是我們的終端機現在的路徑，請將它移動到你的Unity專案的位置，我的Unity專案名字是AITrain_set。因此，使用cd (路徑)，進入。</p><div class="code-wrapper"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> <span class="hljs-params">(路徑)</span> <span class="hljs-string">//cd</span> C:\Users\Lenovo\AITrain_<span class="hljs-keyword">set</span><span class="hljs-keyword">cd</span> <span class="hljs-string">..</span> <span class="hljs-string">//</span>可以回到上一層位置使用時記得目前所在那個位置開始上方案例中，我們的初位置是C:\Users\Lenovo，因此用<span class="hljs-keyword">cd</span> AITrain_<span class="hljs-keyword">set</span>，否則會報錯。</code></pre></div><h4 id="第三步-python下載"><a href="#第三步-python下載" class="headerlink" title="第三步 python下載:"></a>第三步 python下載:</h4><p>接著輸入python</p><p><img src="https://i.imgur.com/VvisJQh.png"></p><p>如果已經有安裝python，那麼就</p><div class="code-wrapper"><pre><code class="hljs awk"><span class="hljs-keyword">exit</span>()</code></pre></div><p>出python就行了。</p><p>如果沒有會彈出Microsoft Store的頁面，在那裏下載python3.7就行了<br><img src="https://i.imgur.com/ILHp8KE.png"></p><h4 id="第四步-增加虛擬環境"><a href="#第四步-增加虛擬環境" class="headerlink" title="第四步 增加虛擬環境:"></a>第四步 增加虛擬環境:</h4><div class="code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">python -m venv venv</span></code></pre></div><p><img src="https://i.imgur.com/PbHjj70.png"><br>如果你現在打開你的Unity專案會發現有一個叫做venv的資料夾已經出現了，那就是我們的虛擬環境。</p><p>之後，我們所以的環境都是裝在這個虛擬環境中，以防它影響到我們電腦本身其他程式的運作。</p><h4 id="第五步-啟動虛擬環境"><a href="#第五步-啟動虛擬環境" class="headerlink" title="第五步 啟動虛擬環境:"></a>第五步 啟動虛擬環境:</h4><div class="code-wrapper"><pre><code class="hljs applescript">venv\Scripts\<span class="hljs-built_in">activate</span></code></pre></div><p>輸入後，你會看到我們的路徑最前方出現(venv)，這樣就完成了。</p><h4 id="第六步-升級pip"><a href="#第六步-升級pip" class="headerlink" title="第六步 升級pip:"></a>第六步 升級pip:</h4><p>pip能幫助我們下載一些額外的功能或模組，在使用之前，我們必須先幫他升級。</p><div class="code-wrapper"><pre><code class="hljs ada">python -m pip install <span class="hljs-comment">--upgrade pip</span></code></pre></div><h4 id="第七步-下載Torch"><a href="#第七步-下載Torch" class="headerlink" title="第七步 下載Torch:"></a>第七步 下載Torch:</h4><p>Torch提供給我們運算機器學習的科學框架，或稱之為基本算式等等，我是這麼理解的。</p><div class="code-wrapper"><pre><code class="hljs awk">pip install torch==<span class="hljs-number">1.7</span>.<span class="hljs-number">0</span> -f https:<span class="hljs-regexp">//</span>download.pytorch.org<span class="hljs-regexp">/whl/</span>torch_stable.html</code></pre></div><h4 id="第八步-下載ML-agents"><a href="#第八步-下載ML-agents" class="headerlink" title="第八步 下載ML-agents:"></a>第八步 下載ML-agents:</h4><p>這就是我們在Unity中使用的AI訓練相關的模組。</p><div class="code-wrapper"><pre><code class="hljs actionscript">pip install mlagents <span class="hljs-comment">//如果出現錯誤訊息的話，請使用下面這一條</span>pip install mlagents --<span class="hljs-keyword">use</span>-feature=<span class="hljs-number">2020</span>-resolver</code></pre></div><h4 id="第九步-測試是否成功下載"><a href="#第九步-測試是否成功下載" class="headerlink" title="第九步 測試是否成功下載:"></a>第九步 測試是否成功下載:</h4><div class="code-wrapper"><pre><code class="hljs ada">mlagents-learn <span class="hljs-comment">--help</span></code></pre></div><p>如果有很多用法提示出現，且沒有出現ERROR或是不同顏色的錯誤訊息，那就完成了。</p><p>出錯解決辦法，我有時間再補上…</p><h4 id="第十步-Unity-package載入"><a href="#第十步-Unity-package載入" class="headerlink" title="第十步 Unity package載入:"></a>第十步 Unity package載入:</h4><p>打開Unity，在上方的選項中選擇window&gt;package manager，進入該頁面後，選擇右上己的齒輪，選擇advanced project setting，打開該頁面後，勾選enable preview package，回到package manager頁面，找到mlagents 1.6下載。</p><p>如果沒有找到1.6版本，可前往下面頁面，照做。</p><p>教程(完成安裝com.unity.ml-agentsUnity軟件包就好):<br><a href="https://github.com/Unity-Technologies/ml-agents/blob/main/docs/Installation.md?fbclid=IwAR3vqQH-y09iYqEEVAPS8IVaND4my-L-nHpXx9X4cCJtr1yxuSFjaHKSxck#advanced-local-installation-for-development">https://github.com/Unity-Technologies/ml-agents/blob/main/docs/Installation.md?fbclid=IwAR3vqQH-y09iYqEEVAPS8IVaND4my-L-nHpXx9X4cCJtr1yxuSFjaHKSxck#advanced-local-installation-for-development</a></p><p>下載點:<br><a href="https://github.com/Unity-Technologies/ml-agents?fbclid=IwAR2Y0NqIYha2ThImYoEw81TU8LraFs_l539MqB05tGlhhEBMvRLoN8m8-_w">https://github.com/Unity-Technologies/ml-agents?fbclid=IwAR2Y0NqIYha2ThImYoEw81TU8LraFs_l539MqB05tGlhhEBMvRLoN8m8-_w</a></p><h2 id="ch2專案建立"><a href="#ch2專案建立" class="headerlink" title="ch2專案建立"></a>ch2專案建立</h2><p>現在完成了A、B、C部分的環境配置後，我們可以正式開始建立我們的ml-agents專案，在這裡，我將建立一個最簡單的範例，”追蹤小球”。</p><p>如果你的英文能力不錯的話，那麼也可以前往Code Monkey大神在Youtube的”How to use Machine Learning AI in Unity! (ML-Agents)”觀看完整版影片。</p><p>影片連結:<a href="https://youtu.be/zPFU30tbyKs">https://youtu.be/zPFU30tbyKs</a></p><h3 id="A部分-建立3D專案"><a href="#A部分-建立3D專案" class="headerlink" title="A部分 建立3D專案"></a>A部分 建立3D專案</h3><p>看我做的影片吧!!!<br>影片連結(高畫質，字樣很清楚，沒字幕):<a href="https://youtu.be/hYrYo-u4los">https://youtu.be/hYrYo-u4los</a></p><h3 id="B部分-開始訓練"><a href="#B部分-開始訓練" class="headerlink" title="B部分 開始訓練"></a>B部分 開始訓練</h3><h4 id="第一步-開啟專案"><a href="#第一步-開啟專案" class="headerlink" title="第一步 開啟專案:"></a>第一步 開啟專案:</h4><p>打開我們建好的Unity專案</p><h4 id="第二步-打開CMD"><a href="#第二步-打開CMD" class="headerlink" title="第二步 打開CMD:"></a>第二步 打開CMD:</h4><p>打開CMD，進入專案底下。</p><h4 id="第三步-啟動虛擬環境"><a href="#第三步-啟動虛擬環境" class="headerlink" title="第三步 啟動虛擬環境:"></a>第三步 啟動虛擬環境:</h4><div class="code-wrapper"><pre><code class="hljs applescript">venv\Scripts\<span class="hljs-built_in">activate</span></code></pre></div><h4 id="第四步-開始訓練"><a href="#第四步-開始訓練" class="headerlink" title="第四步 開始訓練:"></a>第四步 開始訓練:</h4><h5 id=""><a href="#" class="headerlink" title=""></a></h5><div class="code-wrapper"><pre><code class="hljs">注意:訓練之前請確保你的Behavior Name和.yaml檔中的名字一樣。    訓練模式為Default    預設訓練檔下載連結:https://drive.google.com/file/d/1AuOIvefzJO_kFDcfKNLIJELsVSeiXtAD/view?usp=sharing</code></pre></div><p>如果你沒有預設的訓練檔(告訴AI怎麼訓練)，那麼就會用預設的訓練檔去做</p><div class="code-wrapper"><pre><code class="hljs dockerfile">mlagents-learn --<span class="hljs-keyword">run</span><span class="language-bash">-<span class="hljs-built_in">id</span>=(生成的檔案名字) //mlagents-learn --run-id=Goal</span></code></pre></div><p>如果你有的話，就使用下面這行</p><div class="code-wrapper"><pre><code class="hljs dockerfile">mlagents-learn (yaml檔的路徑) --<span class="hljs-keyword">run</span><span class="language-bash">-<span class="hljs-built_in">id</span>=(生成的檔案名字) //mlagents-learn config/MoveToGoal.yaml --run-id=Goal</span></code></pre></div><p>輸入完後，回到Unity按下開始鍵，便會開始訓練了(記得AI的模式要改為Default)</p><h4 id="第五步-打開訓練資料面板"><a href="#第五步-打開訓練資料面板" class="headerlink" title="第五步 打開訓練資料面板"></a>第五步 打開訓練資料面板</h4><p>再開啟一個CMD，進入虛擬環境後，輸入。</p><div class="code-wrapper"><pre><code class="hljs ada">tensorboard <span class="hljs-comment">--logdir results</span></code></pre></div><p>再返回的資料中會出現一段網址，複製，打開你的瀏覽器，貼上，就會進入獲取資料的介面了。</p>]]></content>
    
    
    <categories>
      
      <category>AI-about</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
